#!/usr/bin/env python3
"""
Commix Wrapper for the Exploitation Agent.
This module provides an interface to the Commix tool for command injection exploits.
"""

import subprocess
import os
import json
import re
import logging
import sys
from pathlib import Path

# Add the parent directory to system path to enable imports
sys.path.append(str(Path(__file__).resolve().parent.parent.parent))

from utils.logger import setup_logger

class CommixWrapper:
    """
    Interface for interacting with the Commix command injection tool.
    """
    
    def __init__(self):
        """
        Initialize the Commix wrapper.
        """
        self.logger = setup_logger("commix_wrapper")
        self.logger.info("Initializing Commix Wrapper")
        
        # Check if commix is available
        try:
            subprocess.run(["commix", "--version"], 
                           stdout=subprocess.PIPE, 
                           stderr=subprocess.PIPE, 
                           check=True)
            self.available = True
            self.logger.info("Commix is available")
        except (subprocess.SubprocessError, FileNotFoundError):
            self.available = False
            self.logger.warning("Commix not found. Please install it: apt-get install commix")
    
    def run_exploit(self, target_url, params=None):
        """
        Run Commix against a target URL to exploit command injection vulnerabilities.
        
        Args:
            target_url (str): The target URL to exploit
            params (dict): Additional parameters for the exploit
                Possible parameters:
                - data: POST data string
                - cookie: Cookie header value
                - headers: Additional HTTP headers as dict
                - param: Specific parameter to test
                - level: Level of tests to perform (1-3)
                - technique: Specific technique to use (e.g., "classic", "eval")
                - os: Target OS (e.g., "unix", "windows")
            
        Returns:
            dict: Result of the exploit attempt
        """
        if not self.available:
            self.logger.error("Commix not available")
            return {"success": False, "message": "Commix not installed"}
            
        self.logger.info(f"Running Commix against: {target_url}")
        
        # Start with the basic command
        cmd = ["commix", "--url", target_url, "--batch", "--output-dir", "commix_output"]
        
        # Add the --format=json option if commix supports it (newer versions)
        cmd.append("--format=json")
        
        # Add additional parameters
        if params:
            if "data" in params:
                cmd.extend(["--data", params["data"]])
                
            if "cookie" in params:
                cmd.extend(["--cookie", params["cookie"]])
                
            if "param" in params:
                cmd.extend(["--param", params["param"]])
                
            if "level" in params:
                cmd.extend(["--level", str(params["level"])])
                
            if "technique" in params:
                cmd.extend(["--technique", params["technique"]])
                
            if "os" in params:
                cmd.extend(["--os", params["os"]])
                
            if "headers" in params and isinstance(params["headers"], dict):
                for header, value in params["headers"].items():
                    cmd.extend(["--header", f"{header}: {value}"])
        
        try:
            self.logger.debug(f"Running command: {' '.join(cmd)}")
            
            process = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=600  # 10-minute timeout
            )
            
            # Check if the command was successful (exit code 0 doesn't necessarily mean exploitation success)
            if process.returncode == 0:
                # Try to find success indicators in the output
                if self._check_for_success(process.stdout):
                    # Parse the JSON output if available
                    json_results = self._parse_json_output()
                    
                    result = {
                        "success": True,
                        "message": "Command injection vulnerability exploited successfully",
                        "details": json_results or self._extract_output_details(process.stdout),
                        "raw_output": process.stdout
                    }
                    
                    self.logger.info("Commix exploitation successful")
                    return result
                else:
                    result = {
                        "success": False,
                        "message": "No command injection vulnerability found",
                        "raw_output": process.stdout
                    }
                    
                    self.logger.info("Commix found no command injection vulnerabilities")
                    return result
            else:
                self.logger.warning(f"Commix returned non-zero exit code: {process.returncode}")
                return {
                    "success": False, 
                    "message": f"Commix failed with exit code {process.returncode}",
                    "error": process.stderr,
                    "raw_output": process.stdout
                }
                
        except subprocess.TimeoutExpired:
            self.logger.error("Commix execution timed out after 10 minutes")
            return {"success": False, "message": "Commix execution timed out"}
        except Exception as e:
            self.logger.error(f"Error running Commix: {str(e)}")
            return {"success": False, "message": str(e)}
    
    def _check_for_success(self, output):
        """
        Check if the output indicates successful exploitation.
        
        Args:
            output (str): The output from Commix
            
        Returns:
            bool: True if successful, False otherwise
        """
        success_indicators = [
            "The command execution output",
            "Payload: ",
            "Executing the '",
            "Command execution payload:"
        ]
        
        for indicator in success_indicators:
            if indicator in output:
                return True
                
        return False
    
    def _parse_json_output(self):
        """
        Parse the JSON output file created by Commix.
        
        Returns:
            dict: The parsed JSON data or None if not found
        """
        try:
            # Look for the most recent output file in the commix_output directory
            output_dir = "commix_output"
            if not os.path.exists(output_dir):
                return None
                
            # Find the most recent output file
            json_files = []
            for root, _, files in os.walk(output_dir):
                for file in files:
                    if file.endswith(".json"):
                        json_files.append(os.path.join(root, file))
                        
            if not json_files:
                return None
                
            # Sort by modification time (newest first)
            latest_file = max(json_files, key=os.path.getmtime)
            
            # Parse the JSON file
            with open(latest_file, 'r') as f:
                data = json.load(f)
                return data
                
        except Exception as e:
            self.logger.error(f"Error parsing Commix JSON output: {str(e)}")
            return None
    
    def _extract_output_details(self, output):
        """
        Extract key details from the Commix output text.
        
        Args:
            output (str): The output from Commix
            
        Returns:
            dict: Extracted details
        """
        details = {}
        
        # Extract payload
        payload_match = re.search(r"Payload: (.+)", output)
        if payload_match:
            details["payload"] = payload_match.group(1).strip()
            
        # Extract vulnerable parameter
        param_match = re.search(r"Parameter: (.+?) ", output)
        if param_match:
            details["vulnerable_parameter"] = param_match.group(1).strip()
            
        # Extract OS information
        os_match = re.search(r"identified as (.+?) operating system\.", output)
        if os_match:
            details["os"] = os_match.group(1).strip()
            
        # Extract vulnerability type
        vuln_type_match = re.search(r"Exploitation mode: (.+)", output)
        if vuln_type_match:
            details["vulnerability_type"] = vuln_type_match.group(1).strip()
        
        return details
    
    def clean_outputs(self):
        """
        Clean up Commix output directory.
        """
        try:
            output_dir = "commix_output"
            if os.path.exists(output_dir):
                for root, dirs, files in os.walk(output_dir):
                    for file in files:
                        os.remove(os.path.join(root, file))
                    for dir in dirs:
                        os.rmdir(os.path.join(root, dir))
                os.rmdir(output_dir)
                self.logger.info("Cleaned up Commix output directory")
        except Exception as e:
            self.logger.error(f"Error cleaning Commix output directory: {str(e)}")