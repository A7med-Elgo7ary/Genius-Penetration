#!/usr/bin/env python3
"""
Searchsploit Wrapper for the Exploitation Agent.
This module provides an interface to the Searchsploit tool for finding exploits.
"""

import subprocess
import os
import json
import re
import logging
import sys
from pathlib import Path

# Add the parent directory to system path to enable imports
sys.path.append(str(Path(__file__).resolve().parent.parent.parent))

from utils.logger import setup_logger

class SearchsploitWrapper:
    """
    Interface for interacting with the Searchsploit tool.
    """
    
    def __init__(self):
        """
        Initialize the Searchsploit wrapper.
        """
        self.logger = setup_logger("searchsploit_wrapper")
        self.logger.info("Initializing Searchsploit Wrapper")
        
        # Check if searchsploit is available
        try:
            subprocess.run(["searchsploit", "--version"], 
                           stdout=subprocess.PIPE, 
                           stderr=subprocess.PIPE, 
                           check=True)
            self.available = True
            self.logger.info("Searchsploit is available")
        except (subprocess.SubprocessError, FileNotFoundError):
            self.available = False
            self.logger.warning("Searchsploit not found. Please install exploit-db package.")
    
    def search(self, query, json_output=True):
        """
        Search for exploits using searchsploit.
        
        Args:
            query (str): Search query
            json_output (bool): Whether to output in JSON format
            
        Returns:
            list: List of exploits found
        """
        if not self.available:
            self.logger.error("Searchsploit not available")
            return []
            
        self.logger.info(f"Searching for exploits matching: {query}")
        
        try:
            cmd = ["searchsploit"]
            
            if json_output:
                cmd.append("--json")
                
            # Add the search query
            cmd.append(query)
            
            process = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=True
            )
            
            if json_output:
                try:
                    # Parse the JSON output
                    results = json.loads(process.stdout)
                    exploits = results.get("RESULTS_EXPLOIT", [])
                    self.logger.info(f"Found {len(exploits)} exploits for {query}")
                    return exploits
                except json.JSONDecodeError:
                    self.logger.error("Failed to parse JSON output from searchsploit")
                    return []
            else:
                # Parse the text output
                exploits = self._parse_text_output(process.stdout)
                self.logger.info(f"Found {len(exploits)} exploits for {query}")
                return exploits
                
        except subprocess.SubprocessError as e:
            self.logger.error(f"Error running searchsploit: {str(e)}")
            if e.stderr:
                self.logger.debug(f"searchsploit stderr: {e.stderr}")
            return []
    
    def _parse_text_output(self, output):
        """
        Parse the text output from searchsploit.
        
        Args:
            output (str): Output from searchsploit
            
        Returns:
            list: List of exploits
        """
        exploits = []
        
        lines = output.strip().split('\n')
        
        # Skip the header lines
        start_idx = 0
        for i, line in enumerate(lines):
            if "--------------------------------" in line:
                start_idx = i + 1
                break
        
        # Process each exploit line
        for line in lines[start_idx:]:
            if line.strip() and not line.startswith("Shellcodes:") and not "-------------" in line:
                # Extract exploit ID, title, and path
                try:
                    match = re.match(r"\s*(\d+)\s+\|\s+(.+?)\s+\|\s+(.+)", line)
                    if match:
                        exploit_id, title, path = match.groups()
                        exploits.append({
                            "id": exploit_id.strip(),
                            "title": title.strip(),
                            "path": path.strip(),
                            "type": "exploit"
                        })
                except Exception as e:
                    self.logger.warning(f"Failed to parse exploit line: {line}")
                    
        return exploits
    
    def get_exploit_path(self, exploit_id):
        """
        Get the full path to an exploit file.
        
        Args:
            exploit_id (str): ID of the exploit
            
        Returns:
            str: Path to the exploit file or None if not found
        """
        if not self.available:
            self.logger.error("Searchsploit not available")
            return None
            
        self.logger.info(f"Getting path for exploit ID: {exploit_id}")
        
        try:
            # Use the -p flag to get the full path
            cmd = ["searchsploit", "--path", exploit_id]
            
            process = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=True
            )
            
            output = process.stdout.strip()
            
            # Extract the path from the output
            if '/' in output:
                exploit_path = output.split('\n')[0].strip()
                self.logger.info(f"Found exploit path: {exploit_path}")
                return exploit_path
            else:
                self.logger.warning(f"Exploit path not found for ID: {exploit_id}")
                return None
                
        except subprocess.SubprocessError as e:
            self.logger.error(f"Error getting exploit path: {str(e)}")
            return None
    
    def download_exploit(self, exploit_id, output_dir=None):
        """
        Download an exploit to a specific directory.
        
        Args:
            exploit_id (str): ID of the exploit
            output_dir (str): Directory to save the exploit to
            
        Returns:
            str: Path to the downloaded exploit or None on failure
        """
        if not self.available:
            self.logger.error("Searchsploit not available")
            return None
            
        if not output_dir:
            output_dir = os.path.join(os.path.dirname(__file__), "exploits")
            os.makedirs(output_dir, exist_ok=True)
            
        self.logger.info(f"Downloading exploit ID: {exploit_id} to {output_dir}")
        
        try:
            # Use the -m flag to mirror/download the exploit
            cmd = ["searchsploit", "-m", exploit_id]
            
            # Change to the output directory before running the command
            cwd = os.getcwd()
            os.chdir(output_dir)
            
            process = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=True
            )
            
            # Change back to the original directory
            os.chdir(cwd)
            
            output = process.stdout.strip()
            
            # Check if the download was successful
            if "Exploit mirrored to:" in output:
                # Extract the file path from the output
                file_path = re.search(r"Exploit mirrored to: (.*)", output).group(1).strip()
                
                # If it's a relative path, make it absolute
                if not os.path.isabs(file_path):
                    file_path = os.path.join(output_dir, file_path)
                    
                self.logger.info(f"Downloaded exploit to: {file_path}")
                return file_path
            else:
                self.logger.warning(f"Failed to download exploit ID: {exploit_id}")
                self.logger.debug(f"searchsploit output: {output}")
                return None
                
        except subprocess.SubprocessError as e:
            self.logger.error(f"Error downloading exploit: {str(e)}")
            if e.stderr:
                self.logger.debug(f"searchsploit stderr: {e.stderr}")
            return None