#!/usr/bin/env python3
"""
AI-PenTest Agents - Exploitation Agent Main Controller
Coordinates the exploitation phase of the penetration testing pipeline
Author: AI-PenTest Team
Purpose: Ethical penetration testing and security assessment
"""

import asyncio
import json
import logging
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional

# Add project root to path
project_root = Path(__file__).parent.parent.parent
sys.path.append(str(project_root))

from agents.exploitation_agent.llm_interface import ExploitLLMInterface
from agents.exploitation_agent.tools.metasploit_wrapper import MetasploitWrapper
from agents.exploitation_agent.tools.commix_wrapper import CommixWrapper
from agents.exploitation_agent.tools.searchsploit_wrapper import SearchsploitWrapper
from utils.logger import setup_logger
from utils.config_loader import load_config

class ExploitationAgent:
    """
    Main Exploitation Agent that coordinates vulnerability exploitation
    """
    
    def __init__(self, config_path=None):
        """Initialize the Exploitation Agent"""
        self.config = load_config(config_path) if config_path else {}
        self.logger = setup_logger("ExploitationAgent")
        
        # Initialize components
        self.llm_interface = ExploitLLMInterface()
        self.metasploit = MetasploitWrapper()
        self.commix = CommixWrapper()
        self.searchsploit = SearchsploitWrapper()
        
        # Results storage
        self.exploitation_results = {
            "timestamp": datetime.now().isoformat(),
            "target_info": {},
            "exploitation_attempts": [],
            "successful_exploits": [],
            "failed_exploits": [],
            "sessions_gained": [],
            "summary": {}
        }
        
        self.logger.info("Exploitation Agent initialized successfully")
    def exploit_vulnerabilities(self, vuln_analysis_file: str) -> Dict[str, Any]:
        """
        Main method to exploit vulnerabilities from analysis report.
        
        Args:
            vuln_analysis_file: Path to vulnerability analysis JSON file
            
        Returns:
            Dictionary containing exploitation results
        """
        try:
            self.logger.info("Starting vulnerability exploitation process")
            
            # Load vulnerability analysis data
            vuln_data = self._load_vulnerability_data(vuln_analysis_file)
            if not vuln_data:
                return self.exploitation_results
            
            # Generate exploitation plan using LLM
            exploitation_plan = self.generate_exploitation_plan(vuln_data)
            self.execute_exploitation_plan(exploitation_plan)
            
            # Generate final report
            # self._generate_exploitation_report()
            
            self.logger.info("Vulnerability exploitation process completed")
            return self.exploitation_results
            
        except Exception as e:
            self.logger.error(f"Error in exploitation process: {str(e)}")
            self.exploitation_results["error"] = str(e)
            return self.exploitation_results
    
    def _load_vulnerability_data(self, file_path: str) -> Optional[Dict[str, Any]]:
        """Load and validate vulnerability analysis data."""
        try:
            if not os.path.exists(file_path):
                self.logger.error(f"Vulnerability analysis file not found: {file_path}")
                return None
            
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            # Extract vulnerabilities from the analysis report
            vulnerabilities = []
            if 'detailed_analysis' in data:
                for vuln in data['detailed_analysis']:
                    if vuln.get('exploitable', False):
                        vulnerabilities.append(vuln)
            
            # Before using self.exploitation_results["exploitation_summary"]
            if "exploitation_summary" not in self.exploitation_results:
                self.exploitation_results["exploitation_summary"] = {}
            self.exploitation_results["exploitation_summary"]["total_vulnerabilities"] = len(vulnerabilities)
            self.logger.info(f"Loaded {len(vulnerabilities)} exploitable vulnerabilities")
            
            return {
                "vulnerabilities": vulnerabilities,
                "target_info": data.get('target_info', {}),
                "scan_summary": data.get('scan_summary', {})
            }
            
        except Exception as e:
            self.logger.error(f"Error loading vulnerability data: {str(e)}")
            return None
    def generate_exploitation_plan(self, vuln_report):
        """Generate exploitation plan using LLM"""
        self.logger.info("Generating exploitation plan using LLM...")
        
        try:
            # Extract target information
            target_info = vuln_report.get('target_info', {})
            vulnerabilities = vuln_report.get('vulnerabilities', [])
            
            # Generate plan via LLM
            exploitation_plan = self.llm_interface.generate_exploitation_plan(
                target_info, vulnerabilities
            )
            
            self.exploitation_results["target_info"] = target_info
            self.logger.info(f"Generated exploitation plan with {len(exploitation_plan)} strategies")
            
            return exploitation_plan
        
        except Exception as e:
            self.logger.error(f"Failed to generate exploitation plan: {e}")
            return []
    
    def execute_exploitation_plan(self, exploitation_plan):
        """Execute the generated exploitation plan"""
        self.logger.info("Executing exploitation plan...")
        
        for plan_entry in exploitation_plan:
            try:
                self.logger.info(f"Attempting exploitation: {plan_entry.get('vulnerability_id', 'Unknown')}")
                
                tool = plan_entry.get('tool', '').lower()
                method = plan_entry.get('method', '')
                target = plan_entry.get('target', '')
                
                # Execute based on recommended tool
                if tool == 'metasploit':
                    result = self._execute_metasploit_exploit(plan_entry)
                elif tool == 'commix':
                    result = self._execute_commix_exploit(plan_entry)
                elif tool == 'searchsploit':
                    result = self._execute_searchsploit_exploit(plan_entry)
                elif tool == 'custom':
                    result = self._execute_custom_exploit(plan_entry)
                else:
                    result = self._execute_generic_exploit(plan_entry)
                
                # Record results
                self._record_exploitation_result(plan_entry, result)
                
            except Exception as e:
                self.logger.error(f"Exploitation attempt failed: {e}")
                self._record_exploitation_result(plan_entry, {
                    'success': False,
                    'error': str(e),
                    'timestamp': datetime.now().isoformat()
                })
    
    def _execute_metasploit_exploit(self, plan_entry):
        """Execute Metasploit-based exploitation"""
        self.logger.info("Executing Metasploit exploitation...")
        
        exploit_module = plan_entry.get('exploit_module', '')
        target = plan_entry.get('target', '')
        payload = plan_entry.get('payload', '')
        options = plan_entry.get('options', {})
        
        return self.metasploit.execute_exploit(
            exploit_module=exploit_module,
            target=target,
            payload=payload,
            options=options
        )
    
    def _execute_commix_exploit(self, plan_entry):
        """Execute Commix-based exploitation"""
        self.logger.info("Executing Commix exploitation...")
        
        target_url = plan_entry.get('target', '')
        injection_point = plan_entry.get('injection_point', '')
        technique = plan_entry.get('technique', 'all')
        options = plan_entry.get('options', {})
        
        return self.commix.execute_injection(
            target_url=target_url,
            injection_point=injection_point,
            technique=technique,
            options=options
        )
    
    def _execute_searchsploit_exploit(self, plan_entry):
        """Execute exploit found via Searchsploit"""
        self.logger.info("Executing Searchsploit-based exploitation...")
        
        cve_id = plan_entry.get('cve_id', '')
        search_term = plan_entry.get('search_term', '')
        target = plan_entry.get('target', '')
        
        return self.searchsploit.find_and_execute_exploit(
            cve_id=cve_id,
            search_term=search_term,
            target=target
        )
    
    def _execute_custom_exploit(self, plan_entry):
        """Execute custom LLM-generated exploit"""
        self.logger.info("Executing custom LLM-generated exploit...")
        
        return self.llm_interface.execute_custom_exploit(plan_entry)
    
    def _execute_generic_exploit(self, plan_entry):
        """Execute generic exploitation attempt"""
        self.logger.info("Executing generic exploitation attempt...")
        
        # Try multiple tools based on vulnerability type
        vuln_type = plan_entry.get('vulnerability_type', '').lower()
        
        if 'sql' in vuln_type or 'injection' in vuln_type:
            # Try SQL injection tools
            return self._try_sql_injection_exploits(plan_entry)
        elif 'command' in vuln_type or 'rce' in vuln_type:
            # Try command injection tools
            return self._try_command_injection_exploits(plan_entry)
        elif 'ssh' in vuln_type or 'authentication' in vuln_type:
            # Try authentication exploits
            return self._try_authentication_exploits(plan_entry)
        else:
            # Generic approach
            return self._try_all_exploitation_methods(plan_entry)
    
    def _try_sql_injection_exploits(self, plan_entry):
        """Try SQL injection exploitation methods"""
        results = []
        
        # Try SQLMap via Metasploit
        msf_result = self.metasploit.execute_sql_injection(plan_entry)
        results.append(('metasploit_sql', msf_result))
        
        # Try manual SQL injection via LLM
        llm_result = self.llm_interface.execute_sql_injection(plan_entry)
        results.append(('llm_sql', llm_result))
        
        return self._combine_results(results)
    
    def _try_command_injection_exploits(self, plan_entry):
        """Try command injection exploitation methods"""
        results = []
        
        # Try Commix
        commix_result = self.commix.execute_injection(
            target_url=plan_entry.get('target', ''),
            injection_point=plan_entry.get('injection_point', ''),
            technique='all'
        )
        results.append(('commix', commix_result))
        
        # Try Metasploit command injection modules
        msf_result = self.metasploit.execute_command_injection(plan_entry)
        results.append(('metasploit_cmd', msf_result))
        
        return self._combine_results(results)
    
    def _try_authentication_exploits(self, plan_entry):
        """Try authentication-based exploits"""
        results = []
        
        # Try SSH brute force
        ssh_result = self.metasploit.execute_ssh_exploit(plan_entry)
        results.append(('ssh_exploit', ssh_result))
        
        # Try authentication bypass
        auth_result = self.llm_interface.execute_auth_bypass(plan_entry)
        results.append(('auth_bypass', auth_result))
        
        return self._combine_results(results)
    
    def _try_all_exploitation_methods(self, plan_entry):
        """Try all available exploitation methods"""
        results = []
        
        # Try Searchsploit first
        searchsploit_result = self.searchsploit.find_and_execute_exploit(
            search_term=plan_entry.get('vulnerability_type', ''),
            target=plan_entry.get('target', '')
        )
        results.append(('searchsploit', searchsploit_result))
        
        # Try Metasploit generic
        msf_result = self.metasploit.execute_generic_exploit(plan_entry)
        results.append(('metasploit_generic', msf_result))
        
        # Try LLM custom approach
        llm_result = self.llm_interface.execute_custom_exploit(plan_entry)
        results.append(('llm_custom', llm_result))
        
        return self._combine_results(results)
    
    def _combine_results(self, results):
        """Combine multiple exploitation attempt results"""
        combined = {
            'success': False,
            'attempts': [],
            'successful_method': None,
            'session_info': None,
            'timestamp': datetime.now().isoformat()
        }
        
        for method, result in results:
            combined['attempts'].append({
                'method': method,
                'result': result
            })
            
            if result.get('success', False):
                combined['success'] = True
                combined['successful_method'] = method
                if result.get('session_info'):
                    combined['session_info'] = result['session_info']
                break  # Use first successful method
        
        return combined
    
    def _record_exploitation_result(self, plan_entry, result):
        """Record exploitation attempt result"""
        attempt_record = {
            'vulnerability_id': plan_entry.get('vulnerability_id', ''),
            'vulnerability_type': plan_entry.get('vulnerability_type', ''),
            'target': plan_entry.get('target', ''),
            'tool': plan_entry.get('tool', ''),
            'method': plan_entry.get('method', ''),
            'result': result,
            'timestamp': datetime.now().isoformat()
        }
        
        self.exploitation_results['exploitation_attempts'].append(attempt_record)
        
        if result.get('success', False):
            self.exploitation_results['successful_exploits'].append(attempt_record)
            if result.get('session_info'):
                self.exploitation_results['sessions_gained'].append(result['session_info'])
        else:
            self.exploitation_results['failed_exploits'].append(attempt_record)
    
    def generate_summary(self):
        """Generate exploitation summary"""
        total_attempts = len(self.exploitation_results['exploitation_attempts'])
        successful_exploits = len(self.exploitation_results['successful_exploits'])
        failed_exploits = len(self.exploitation_results['failed_exploits'])
        sessions_gained = len(self.exploitation_results['sessions_gained'])
        
        success_rate = (successful_exploits / total_attempts * 100) if total_attempts > 0 else 0
        
        summary = {
            'total_exploitation_attempts': total_attempts,
            'successful_exploits': successful_exploits,
            'failed_exploits': failed_exploits,
            'success_rate_percentage': round(success_rate, 2),
            'sessions_gained': sessions_gained,
            'most_successful_tool': self._get_most_successful_tool(),
            'vulnerability_types_exploited': self._get_exploited_vuln_types(),
            'recommendations': self._generate_recommendations()
        }
        
        self.exploitation_results['summary'] = summary
        return summary
    
    def _get_most_successful_tool(self):
        """Get the most successful exploitation tool"""
        tool_success = {}
        
        for attempt in self.exploitation_results['successful_exploits']:
            tool = attempt.get('tool', 'unknown')
            tool_success[tool] = tool_success.get(tool, 0) + 1
        
        if tool_success:
            return max(tool_success, key=tool_success.get)
        return None
    
    def _get_exploited_vuln_types(self):
        """Get list of successfully exploited vulnerability types"""
        vuln_types = set()
        
        for attempt in self.exploitation_results['successful_exploits']:
            vuln_type = attempt.get('vulnerability_type', '')
            if vuln_type:
                vuln_types.add(vuln_type)
        
        return list(vuln_types)
    
    def _generate_recommendations(self):
        """Generate recommendations based on exploitation results"""
        recommendations = []
        
        success_rate = self.exploitation_results['summary'].get('success_rate_percentage', 0)
        
        if success_rate > 50:
            recommendations.append("High exploitation success rate indicates significant security vulnerabilities")
            recommendations.append("Immediate patching and security hardening recommended")
        elif success_rate > 20:
            recommendations.append("Moderate exploitation success rate requires attention")
            recommendations.append("Review and patch identified vulnerabilities")
        else:
            recommendations.append("Low exploitation success rate indicates good security posture")
            recommendations.append("Continue monitoring and maintain current security measures")
        
        if self.exploitation_results['sessions_gained']:
            recommendations.append("Shell access gained - implement network segmentation and monitoring")
        
        return recommendations
    
    def save_results(self, output_path=None):
        """Save exploitation results to file"""
        if not output_path:
            output_dir = Path(__file__).parent / "output"
            output_dir.mkdir(exist_ok=True)
            output_path = output_dir / "exploit_attempts.json"
        
        try:
            with open(output_path, 'w') as f:
                json.dump(self.exploitation_results, f, indent=2)
            
            self.logger.info(f"Exploitation results saved to: {output_path}")
            return str(output_path)
        
        except Exception as e:
            self.logger.error(f"Failed to save results: {e}")
            return None
    
    def run_exploitation(self, vuln_report_path, output_path=None):
        """Main method to run complete exploitation process"""
        self.logger.info("Starting exploitation phase...")
        
        # Load vulnerability report
        vuln_report = self.load_vulnerability_report(vuln_report_path)
        if not vuln_report:
            self.logger.error("Failed to load vulnerability report")
            return False
        
        # Generate exploitation plan
        exploitation_plan = self.generate_exploitation_plan(vuln_report)
        if not exploitation_plan:
            self.logger.error("Failed to generate exploitation plan")
            return False
        
        # Execute exploitation attempts
        self.execute_exploitation_plan(exploitation_plan)
        
        # Generate summary
        summary = self.generate_summary()
        self.logger.info(f"Exploitation completed - Success rate: {summary['success_rate_percentage']}%")
        
        # Save results
        output_file = self.save_results(output_path)
        
        return True if output_file else False

async def main():
    """Main function for testing the Exploitation Agent."""
    try:
        # Initialize the agent
        agent = ExploitationAgent()
        
        # Path to vulnerability analysis report
        vuln_analysis_file = "agents/vulnerability_analysis_agent/output/vuln_analysis_report.json"
        
        # Check if the analysis file exists
        if not os.path.exists(vuln_analysis_file):
            print(f"Vulnerability analysis file not found: {vuln_analysis_file}")
            print("Please run the Vulnerability Analysis Agent first.")
            return
        
        # Run exploitation
        results = agent.exploit_vulnerabilities(vuln_analysis_file)
        
        print("\n" + "="*50)
        print("EXPLOITATION AGENT RESULTS")
        print("="*50)
        print(f"Total vulnerabilities analyzed: {results['summary'].get('total_exploitation_attempts', 0)}")
        print(f"Exploitation attempts: {results['summary'].get('total_exploitation_attempts', 0)}")
        print(f"Successful exploits: {results['summary'].get('successful_exploits', 0)}")
        print(f"Failed exploits: {results['summary'].get('failed_exploits', 0)}")
        print(f"Active sessions: {results['summary'].get('sessions_gained', 0)}")
        
        if results['sessions_gained']:
            print("\nActive Sessions:")
            for session in results['sessions_gained']:
                print(f"  - {session.get('session_type', 'unknown')} on {session.get('target', 'unknown')} (ID: {session.get('session_id', 'N/A')})")
        
        print(f"\nDetailed results saved to: agents/exploitation_agent/output/exploit_attempts.json")
        
    except KeyboardInterrupt:
        print("\nExploitation interrupted by user")
    except Exception as e:
        print(f"Error running exploitation agent: {str(e)}")


if __name__ == "__main__":
    asyncio.run(main())