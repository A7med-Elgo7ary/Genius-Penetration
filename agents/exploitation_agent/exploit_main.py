#!/usr/bin/env python3
"""
Main entry point for the Exploitation Agent.
This agent attempts to exploit vulnerabilities identified by the Vulnerability Analysis Agent.
"""

import os
import json
import argparse
import logging
from datetime import datetime
import sys
from pathlib import Path

# Add the parent directory to system path to enable imports
sys.path.append(str(Path(__file__).resolve().parent.parent.parent))

from agents.exploitation_agent.tools.searchsploit_wrapper import SearchsploitWrapper
from utils.logger import setup_logger
from utils.config_loader import load_config
from exploitation_agent.llm_interface import ExploitLLMInterface
from agents.exploitation_agent.tools.metasploit_rpc import MetasploitRPC
from agents.exploitation_agent.tools.commix_wrapper import CommixWrapper



class ExploitationAgent:
    """
    Agent responsible for attempting to exploit vulnerabilities identified
    during the vulnerability analysis phase.
    """
    
    def __init__(self, config_path=None, vuln_analysis_report_path=None):
        """
        Initialize the Exploitation Agent.
        
        Args:
            config_path (str): Path to the configuration file
            vuln_analysis_report_path (str): Path to the vulnerability analysis report
        """
        # Setup logging
        self.logger = setup_logger("exploitation_agent")
        self.logger.info("Initializing Exploitation Agent")
        
        # Load configuration
        self.config = load_config(config_path) if config_path else {}
        
        # Initialize exploit results tracking
        self.exploit_results = {
            "timestamp": datetime.now().isoformat(),
            "target": None,
            "successful_exploits": [],
            "failed_exploits": [],
            "sessions": {}
        }
        
        # Load vulnerability analysis report
        self.vuln_analysis_report_path = vuln_analysis_report_path
        self.vuln_analysis_data = self._load_vuln_analysis_data()
        
        if self.vuln_analysis_data:
            self.exploit_results["target"] = self.vuln_analysis_data.get("target", "Unknown")
            
        # Initialize LLM interface
        self.llm = ExploitLLMInterface(self.config.get("llm", {}))
        
        # Initialize tools
        self._initialize_tools()
        
    def _initialize_tools(self):
        """Initialize all exploitation tools."""
        try:
            # Initialize Metasploit RPC client
            msf_config = self.config.get("metasploit", {})
            self.metasploit = MetasploitRPC(
                host=msf_config.get("host", "127.0.0.1"),
                port=msf_config.get("port", 55552),
                username=msf_config.get("username", "msf"),
                password=msf_config.get("password", "password"),
                ssl=msf_config.get("ssl", False)
            )
            
            # Initialize Searchsploit wrapper
            self.searchsploit = SearchsploitWrapper()
            
            # Initialize Commix wrapper
            self.commix = CommixWrapper()
            
            self.logger.info("All exploitation tools initialized successfully")
        except Exception as e:
            self.logger.error(f"Error initializing exploitation tools: {str(e)}")
            raise
    
    def _load_vuln_analysis_data(self):
        """
        Load vulnerability analysis data from the report file.
        
        Returns:
            dict: The vulnerability analysis data or None if file not found
        """
        if not self.vuln_analysis_report_path:
            # Check the default path based on project structure
            default_path = "../vulnerability_analysis_agent/output/vuln_analysis_report.json"
            if os.path.exists(default_path):
                self.vuln_analysis_report_path = default_path
            else:
                self.logger.error("No vulnerability analysis report path provided and default path not found")
                return None
                
        try:
            with open(self.vuln_analysis_report_path, 'r') as f:
                data = json.load(f)
                self.logger.info(f"Loaded vulnerability analysis data for target: {data.get('target', 'Unknown')}")
                return data
        except FileNotFoundError:
            self.logger.error(f"Vulnerability analysis report not found at {self.vuln_analysis_report_path}")
            return None
        except json.JSONDecodeError:
            self.logger.error(f"Invalid JSON in vulnerability analysis report at {self.vuln_analysis_report_path}")
            return None
    
    def run(self):
        """
        Execute the exploitation phase.
        """
        if not self.vuln_analysis_data:
            self.logger.error("No vulnerability analysis data available. Cannot proceed with exploitation.")
            return False
            
        self.logger.info("Starting exploitation phase")
        
        # Let the LLM analyze the vulnerabilities and decide on exploitation strategy
        exploitation_plan = self.llm.generate_exploitation_plan(self.vuln_analysis_data)
        
        # Track overall success
        any_success = False
        
        # Execute the exploitation plan
        for vuln_id, exploit_details in exploitation_plan.items():
            success = self._execute_exploit(vuln_id, exploit_details)
            if success:
                any_success = True
                
        # Save results
        self._save_results()
        
        if any_success:
            self.logger.info("Exploitation phase completed with at least one successful exploit")
        else:
            self.logger.info("Exploitation phase completed without any successful exploits")
            
        return any_success
    
    def _execute_exploit(self, vuln_id, exploit_details):
        """
        Execute an exploit based on the details provided.
        
        Args:
            vuln_id (str): ID of the vulnerability
            exploit_details (dict): Details of the exploit to use
            
        Returns:
            bool: True if exploitation was successful, False otherwise
        """
        tool = exploit_details.get("tool", "").lower()
        method = exploit_details.get("method", "")
        target = exploit_details.get("target", "")
        params = exploit_details.get("params", {})
        
        try:
            self.logger.info(f"Attempting to exploit vulnerability {vuln_id} using {tool}")
            
            if tool == "metasploit":
                result = self.metasploit.run_exploit(method, target, params)
            elif tool == "commix":
                result = self.commix.run_exploit(target, params)
            elif tool == "custom":
                # Let the LLM generate custom exploitation code
                result = self.llm.execute_custom_exploit(method, target, params)
            else:
                self.logger.warning(f"Unknown exploitation tool: {tool}")
                result = {"success": False, "message": f"Unknown exploitation tool: {tool}"}
            
            # Record the result
            if result.get("success", False):
                self.exploit_results["successful_exploits"].append({
                    "vuln_id": vuln_id,
                    "tool": tool,
                    "method": method,
                    "target": target,
                    "details": result
                })
                # If we got a session, record it
                if "session_id" in result:
                    self.exploit_results["sessions"][result["session_id"]] = {
                        "vuln_id": vuln_id,
                        "tool": tool,
                        "type": result.get("session_type", "unknown")
                    }
                self.logger.info(f"Successfully exploited vulnerability {vuln_id}")
                return True
            else:
                self.exploit_results["failed_exploits"].append({
                    "vuln_id": vuln_id,
                    "tool": tool,
                    "method": method,
                    "target": target,
                    "reason": result.get("message", "Unknown reason")
                })
                self.logger.warning(f"Failed to exploit vulnerability {vuln_id}: {result.get('message', 'Unknown reason')}")
                return False
                
        except Exception as e:
            self.logger.error(f"Error while attempting to exploit {vuln_id}: {str(e)}")
            self.exploit_results["failed_exploits"].append({
                "vuln_id": vuln_id,
                "tool": tool,
                "method": method,
                "target": target,
                "reason": str(e)
            })
            return False
    
    def _save_results(self):
        """
        Save exploitation results to JSON file.
        """
        output_dir = os.path.join(os.path.dirname(__file__), "output")
        os.makedirs(output_dir, exist_ok=True)
        
        output_path = os.path.join(output_dir, "exploit_attempts.json")
        
        try:
            with open(output_path, 'w') as f:
                json.dump(self.exploit_results, f, indent=4)
            self.logger.info(f"Exploitation results saved to {output_path}")
        except Exception as e:
            self.logger.error(f"Error saving exploitation results: {str(e)}")

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="AI-PenTest Exploitation Agent")
    parser.add_argument("--config", help="Path to configuration file", default="../../config/config.yaml")
    parser.add_argument("--vuln-report", help="Path to vulnerability analysis report", 
                        default="../vulnerability_analysis_agent/output/vuln_analysis_report.json")
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_arguments()
    
    try:
        agent = ExploitationAgent(
            config_path=args.config,
            vuln_analysis_report_path=args.vuln_report
        )
        success = agent.run()
        sys.exit(0 if success else 1)
    except Exception as e:
        logging.error(f"Unhandled exception: {str(e)}")
        sys.exit(1)