"""
LLM Interface for the Vulnerability Scanning Agent.
This module handles all interactions with the Gemini API for vulnerability scanning tasks.
"""

import os
import json
import time
from typing import Dict, List, Any, Optional, Callable
import logging
import google.generativeai as genai
from google.generativeai.types import GenerationConfig
import subprocess

class VulnScanLLMInterface:
    """Interface for interacting with the Gemini API for vulnerability scanning tasks."""
    
    def __init__(self, api_key: str, model: str = "gemini-2.5-flash-preview-04-17", logger=None):
        """
        Initialize the LLM interface with the Gemini API.
        
        Args:
            api_key: Gemini API key
            model: Model name to use
            logger: Logger instance
        """
        self.api_key = api_key
        self.model = model
        self.logger = logger or logging.getLogger(__name__)
        
        # Configure the Gemini API
        genai.configure(api_key=api_key)
        
        # Default generation config
        self.generation_config = GenerationConfig(
            temperature=0.2,
            top_p=0.95,
            top_k=40,
            max_output_tokens=8192,
        )
        
        # System prompt for vulnerability scanning
        self.system_prompt = """
        You are an expert cybersecurity vulnerability scanning agent running in Kali Linux 2025. 
        You have complete access to various vulnerability scanning tools in this environment. 
        Your task is to identify security vulnerabilities in the target systems using the most effective tools and techniques.
        
        You can access and utilize the following tools:
        - Nmap: For network scanning, service detection, and initial vulnerability detection
        - Masscan: For rapid port scanning of large networks
        - Nikto: For web server vulnerability scanning
        - OWASP ZAP: For comprehensive web application vulnerability scanning
        - sqlmap: For SQL injection detection and exploitation
        - XSSer: For Cross-Site Scripting (XSS) detection and testing
        - WPScan: For WordPress specific vulnerabilities
        - dirb/gobuster: For directory and file brute-forcing
        - Nuclei: For template-based vulnerability scanning
        
        Be precise in your commands and interpret the results accurately.
        Format all outputs as structured JSON that can be easily processed by other agents in the pipeline.
        Categorize vulnerabilities by severity (Critical, High, Medium, Low).
        Provide recommendations for each identified vulnerability.
        """
    
    def _call_gemini(self, prompt: str, system_prompt: str = None) -> str:
        """
        Make a call to the Gemini API.
        
        Args:
            prompt: User prompt to send to the API
            system_prompt: Optional system prompt override
            
        Returns:
            API response text
        """
        try:
            model = genai.GenerativeModel(
                model_name=self.model,
                generation_config=self.generation_config
            )
            
            # Create the chat session
            chat = model.start_chat(history=[])
            
            # Add the system prompt if provided
            if system_prompt:
                response = chat.send_message(f"System: {system_prompt}\n\nUser: {prompt}")
            else:
                response = chat.send_message(f"System: {self.system_prompt}\n\nUser: {prompt}")
            
            return response.text
            
        except Exception as e:
            self.logger.error(f"Error calling Gemini API: {str(e)}")
            raise
    
    def determine_scan_strategy(self, scan_targets: Dict[str, List[str]], 
                               available_scanners: List[str],
                               recon_data: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Use the LLM to determine the best vulnerability scanning strategy for the targets.
        
        Args:
            scan_targets: Dictionary of different target types (domains, IPs, etc.)
            available_scanners: List of available scanning tools
            recon_data: Optional reconnaissance data from previous agent
            
        Returns:
            Dict containing vulnerability scanning strategy
        """
        # Create a simplified version of recon_data to avoid token limit
        recon_summary = {}
        if recon_data:
            recon_summary["target"] = recon_data.get("target", "")
            if "findings" in recon_data:
                recon_summary["findings"] = {}
                for tool, data in recon_data["findings"].items():
                    if "analysis" in data:
                        recon_summary["findings"][tool] = data["analysis"]
                    elif "summary" in data:
                        recon_summary["findings"][tool] = data["summary"]
        
        prompt = f"""
        I need to perform vulnerability scanning on the following targets:
        
        {json.dumps(scan_targets, indent=2)}
        
        Available scanning tools: {', '.join(available_scanners)}
        
        Reconnaissance data summary: {json.dumps(recon_summary, indent=2) if recon_data else "Not available"}
        
        Please help me determine the most effective vulnerability scanning strategy by:
        1. Deciding the optimal order to run these scanning tools
        2. Specifying which targets should be scanned with each tool
        3. Providing specific configuration parameters for each tool
        4. Explaining your reasoning for this strategy
        
        Provide your response as a JSON object with the following structure:
        {{
            "scanner_order": ["ordered", "list", "of", "scanners"],
            "scanner_configs": {{
                "scanner1": {{
                    "targets": ["target1", "target2"],
                    "params": {{"param1": "value1", "param2": "value2"}}
                }},
                "scanner2": {{
                    "targets": ["target1", "target3"],
                    "params": {{"param1": "value1", "param2": "value2"}}
                }}
            }},
            "reasoning": "explanation of your strategy"
        }}
        
        Consider the specific strengths and use cases of each scanning tool:
        - Nmap is best for network service discovery and initial vulnerability assessment
        - Masscan is ideal for rapid port scanning of large IP ranges and networks
        - Nikto is good for web server security issues
        - ZAP is comprehensive for web applications
        - sqlmap specializes in SQL injection
        - XSSer focuses on detecting and testing Cross-Site Scripting vulnerabilities
        - WPScan is WordPress-specific
        - dirb/gobuster are for discovering hidden files and directories
        - Nuclei is for template-based scanning across multiple targets
        
        Prioritize efficiency by not running redundant scans and be mindful of potentially intrusive scans.
        """
        
        response = self._call_gemini(prompt)
        
        # Parse the JSON response
        try:
            # Extract JSON from the response text if needed
            json_start = response.find("{")
            json_end = response.rfind("}") + 1
            if json_start >= 0 and json_end > json_start:
                json_str = response[json_start:json_end]
                result = json.loads(json_str)
            else:
                self.logger.warning("Could not extract JSON from response, using full response")
                result = json.loads(response)
                
            return result
        except json.JSONDecodeError:
            self.logger.error("Failed to parse LLM response as JSON")
            # Return a basic fallback strategy
            return {
                "scanner_order": available_scanners,
                "scanner_configs": {scanner: {"targets": list(scan_targets.get("web_servers", [])), "params": {}} 
                                   for scanner in available_scanners},
                "reasoning": "Default strategy due to LLM parsing failure"
            }
    
    def generate_scanner_prompt(self, scanner_name: str, scan_targets: List[str], scanner_config: Dict[str, Any]) -> str:
        """
        Generate a scanner-specific prompt for the LLM.
        
        Args:
            scanner_name: Name of the scanner
            scan_targets: List of targets for this scanner
            scanner_config: Scanner configuration parameters
            
        Returns:
            Scanner-specific prompt
        """
        # Prepare scanner-specific guidance
        scanner_guidance = {
            "nmap": "Focus on identifying open ports, services, versions, and potential vulnerabilities",
            "nikto": "Look for web server misconfigurations, dangerous files, and known vulnerabilities",
            "zap": "Perform comprehensive web application scanning including XSS, CSRF, and injection flaws",
            "sqlmap": "Test for SQL injection vulnerabilities in web applications",
            "wpscan": "Identify WordPress vulnerabilities, plugins, themes, and user enumeration",
            "dirb": "Discover hidden directories and files on web servers",
            "gobuster": "Brute force directories and files with custom wordlists if available",
            "nuclei": "Run template-based scans for known vulnerabilities, misconfigurations, and exposures"
        }
        
        guidance = scanner_guidance.get(scanner_name.lower(), "Perform a comprehensive scan")
        
        # Create parameter string from scanner_config
        params = scanner_config.get("params", {})
        params_str = json.dumps(params, indent=2) if params else "No specific parameters provided"
        
        prompt = f"""
        I need to use {scanner_name} to scan the following targets:
        
        {json.dumps(scan_targets, indent=2)}
        
        Scanner configuration parameters: {params_str}
        
        Guidance for this scan: {guidance}
        
        Please provide:
        1. The exact command(s) to run in Kali Linux 2025, including all necessary flags and parameters
        2. An explanation of what vulnerabilities we're looking for
        3. How to interpret the results
        4. Any potential false positives to be aware of
        
        For command-line tools, use the actual tool commands. For wrapped tools (ZAP, etc.), provide the appropriate API calls or parameters.
        Be thorough but efficient in your scanning strategy.
        """
        
        response = self._call_gemini(prompt)
        return response
    
    def execute_scanner(self, scanner_name: str, scan_targets: List[str], 
                       prompt: str, scanner_instance: Any) -> Dict[str, Any]:
        """
        Execute a vulnerability scanner using the LLM-generated prompt.
        
        Args:
            scanner_name: Name of the scanner
            scan_targets: List of targets to scan
            prompt: LLM-generated prompt for scanner execution
            scanner_instance: Instance of the scanner class

        Returns:
            Dict containing scanner execution results
        """
        self.logger.info(f"Executing {scanner_name} with LLM guidance")
        
        # Generate the LLM-guided command or parameters
        scanner_guidance_prompt = f"""
        Based on the scanner execution plan:
        
        {prompt}
        
        For the targets: {json.dumps(scan_targets, indent=2)}
        
        Please generate:
        1. If this is a direct command-line tool (nmap, nikto, etc.): The exact command(s) to run in Kali Linux
        2. If this is a Python wrapper: The exact parameters to use with the Python interface as a JSON object
        
        Be precise and include all necessary flags and options for thorough vulnerability scanning.
        """
        
        command_response = self._call_gemini(scanner_guidance_prompt)
        
        # Check if this is a direct command-line tool or a Python wrapper
        is_direct_command = scanner_name.lower() in ["nmap", "nikto", "sqlmap", "wpscan", "dirb", "gobuster"]
        
        if is_direct_command:
            # Extract the command from the response
            command_lines = [line.strip() for line in command_response.split('\n') 
                           if line.strip().startswith(scanner_name.lower())]
            
            if not command_lines:
                # Try to find code blocks that might contain the command
                import re
                code_blocks = re.findall(r'```(?:bash|shell)?\s*(.*?)```', command_response, re.DOTALL)
                for block in code_blocks:
                    lines = [line.strip() for line in block.split('\n') 
                           if line.strip().startswith(scanner_name.lower())]
                    if lines:
                        command_lines = lines
                        break
            
            if not command_lines:
                self.logger.warning(f"Could not extract command for {scanner_name}, using default")
                # Create a basic default command
                if scanner_name.lower() == "nmap":
                    command_lines = [f"nmap -sV -sC -oA nmap_scan {' '.join(scan_targets)}"]
                elif scanner_name.lower() == "nikto":
                    command_lines = [f"nikto -h {target}" for target in scan_targets]
                elif scanner_name.lower() == "sqlmap":
                    command_lines = [f"sqlmap -u {target} --batch --level=1 --risk=1" for target in scan_targets]
                elif scanner_name.lower() == "wpscan":
                    command_lines = [f"wpscan --url {target} --enumerate p,t,u" for target in scan_targets]
                elif scanner_name.lower() == "dirb":
                    command_lines = [f"dirb {target} /usr/share/wordlists/dirb/common.txt" for target in scan_targets]
                elif scanner_name.lower() == "gobuster":
                    command_lines = [f"gobuster dir -u {target} -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt" for target in scan_targets]
            
            # Execute the commands and collect results
            results = {"commands": command_lines, "outputs": []}
            
            for cmd in command_lines:
                self.logger.info(f"Running command: {cmd}")
                try:
                    process = subprocess.Popen(
                        cmd, 
                        shell=True, 
                        stdout=subprocess.PIPE, 
                        stderr=subprocess.PIPE,
                        text=True
                    )
                    stdout, stderr = process.communicate(timeout=900)  # 15-minute timeout
                    
                    results["outputs"].append({
                        "command": cmd,
                        "stdout": stdout,
                        "stderr": stderr,
                        "return_code": process.returncode
                    })
                    
                except subprocess.TimeoutExpired:
                    self.logger.warning(f"Command timed out: {cmd}")
                    results["outputs"].append({
                        "command": cmd,
                        "error": "Command timed out after 15 minutes",
                        "stdout": "",
                        "stderr": "",
                        "return_code": -1
                    })
                except Exception as e:
                    self.logger.error(f"Error executing command {cmd}: {str(e)}")
                    results["outputs"].append({
                        "command": cmd,
                        "error": str(e),
                        "stdout": "",
                        "stderr": "",
                        "return_code": -1
                    })
            
            return results
        else:
            # Extract parameters for Python wrapper
            try:
                # Find JSON in the response
                json_start = command_response.find("{")
                json_end = command_response.rfind("}") + 1
                if json_start >= 0 and json_end > json_start:
                    json_str = command_response[json_start:json_end]
                    parameters = json.loads(json_str)
                else:
                    self.logger.warning(f"Could not extract JSON from parameters response for {scanner_name}, using empty parameters")
                    parameters = {}
            except json.JSONDecodeError:
                self.logger.warning(f"Failed to parse parameters for {scanner_name}, using defaults")
                parameters = {}
            
            # Execute the scanner with the parameters
            target_results = {}
            for target in scan_targets:
                try:
                    # Most scanners will have a scan method
                    if hasattr(scanner_instance, 'scan') and callable(getattr(scanner_instance, 'scan')):
                        target_results[target] = scanner_instance.scan(target, **parameters)
                    else:
                        # Try to find any method that takes a target parameter
                        for attr_name in dir(scanner_instance):
                            attr = getattr(scanner_instance, attr_name)
                            if callable(attr) and not attr_name.startswith('_'):
                                try:
                                    target_results[target] = attr(target, **parameters)
                                    break
                                except Exception:
                                    continue
                        else:
                            raise ValueError(f"Could not find a suitable method to run in {scanner_name}")
                except Exception as e:
                    self.logger.error(f"Error scanning {target} with {scanner_name}: {str(e)}")
                    target_results[target] = {"error": str(e)}
            
            return {
                "parameters": parameters,
                "results": target_results
            }
    
    def process_scanner_output(self, scanner_name: str, scanner_output: Dict[str, Any], 
                             scan_targets: List[str]) -> Dict[str, Any]:
        """
        Process and analyze the output from a vulnerability scanner using the LLM.
        
        Args:
            scanner_name: Name of the scanner
            scanner_output: Raw output from the scanner
            scan_targets: List of scanned targets
            
        Returns:
            Dict containing processed and analyzed results with vulnerability categorization
        """
        # Prepare a summary of the output to avoid token limits
        output_summary = {}
        
        # For command-line tools
        if "outputs" in scanner_output:
            outputs = scanner_output["outputs"]
            # Limit the size to avoid token limits
            for i, output in enumerate(outputs):
                if "stdout" in output:
                    # Limit stdout to 10000 characters
                    if len(output["stdout"]) > 10000:
                        output_summary[f"output_{i}_truncated"] = output["stdout"][:10000] + "... [truncated]"
                    else:
                        output_summary[f"output_{i}"] = output["stdout"]
        else:
            # For Python wrapper tools
            output_summary = scanner_output
            
        # Create a scanner-specific prompt for output analysis
        analysis_prompt = f"""
        Analyze the following {scanner_name} scan results for these targets: {json.dumps(scan_targets)}
        
        Scanner output summary:
        {json.dumps(output_summary, indent=2)}
        
        Please provide:
        1. A summary of all identified vulnerabilities
        2. Categorization of each vulnerability by severity (Critical, High, Medium, Low)
        3. Potential impact of each vulnerability
        4. Recommendations for remediation
        5. Any false positives that might be present
        
        Format your response as a JSON object with these sections:
        {{
            "summary": "Overall summary of findings",
            "vulnerabilities": [
                {{
                    "name": "Vulnerability name",
                    "severity": "Critical/High/Medium/Low",
                    "description": "Description of the vulnerability",
                    "impact": "Potential impact",
                    "remediation": "Recommended fix",
                    "affected_targets": ["target1", "target2"],
                    "is_likely_false_positive": false
                }},
                ...
            ],
            "vulnerability_counts": {{
                "critical": 1,
                "high": 2,
                "medium": 3,
                "low": 4
            }}
        }}
        """
            
        response = self._call_gemini(analysis_prompt)
        
        try:
            # Extract JSON from the response
            json_start = response.find("{")
            json_end = response.rfind("}") + 1
            if json_start >= 0 and json_end > json_start:
                processed_results = json.loads(response[json_start:json_end])
            else:
                processed_results = json.loads(response)
                
            # Add the original data in a compressed form
            processed_results["raw_data"] = {"note": "Original scanner output stored internally"}
            
            return processed_results
            
        except json.JSONDecodeError:
            self.logger.error(f"Failed to parse LLM analysis for {scanner_name}")
            
            # Try to make a simpler response
            simple_prompt = f"""
            Please extract just the number of vulnerabilities found by severity from the {scanner_name} scan.
            Return only a JSON object with counts:
            {{
                "critical": 0,
                "high": 0, 
                "medium": 0,
                "low": 0
            }}
            """
            
            try:
                simple_response = self._call_gemini(simple_prompt)
                json_start = simple_response.find("{")
                json_end = simple_response.rfind("}") + 1
                if json_start >= 0 and json_end > json_start:
                    counts = json.loads(simple_response[json_start:json_end])
                    return {
                        "summary": f"Analysis failed, but detected {sum(counts.values())} vulnerabilities",
                        "vulnerability_counts": counts,
                        "raw_data": {"note": "Original scanner output stored internally"}
                    }
            except:
                pass
                
            return {
                "error": "Failed to parse LLM analysis",
                "summary": "Failed to analyze scanner output",
                "vulnerability_counts": {"critical": 0, "high": 0, "medium": 0, "low": 0},
                "raw_data": {"note": "Original scanner output stored internally"}
            }
    
    def analyze_scan_data(self, combined_results: Dict[str, Any], 
                        scan_targets: Dict[str, List[str]]) -> Dict[str, Any]:
        """
        Use the LLM to analyze the complete vulnerability scanning dataset.
        
        Args:
            combined_results: Combined results from all scanners
            scan_targets: Dictionary of target types
            
        Returns:
            Dict containing vulnerability insights and recommendations
        """
        # Prepare a summary of the data to avoid token limits
        scanner_summary = {}
        if "findings" in combined_results:
            for scanner_name, scanner_data in combined_results["findings"].items():
                summary = {}
                
                # Extract vulnerability counts
                if "vulnerability_counts" in scanner_data:
                    summary["vulnerability_counts"] = scanner_data["vulnerability_counts"]
                
                # Extract summary if available
                if "summary" in scanner_data:
                    summary["summary"] = scanner_data["summary"]
                
                # Extract top vulnerabilities (limit to 5 per scanner)
                if "vulnerabilities" in scanner_data and isinstance(scanner_data["vulnerabilities"], list):
                    summary["top_vulnerabilities"] = scanner_data["vulnerabilities"][:5]
                
                scanner_summary[scanner_name] = summary
        
        prompt = f"""
        I have completed vulnerability scanning on the following targets:
        
        {json.dumps(scan_targets, indent=2)}
        
        Here is a summary of the findings from each scanner:
        
        {json.dumps(scanner_summary, indent=2)}
        
        Please provide a comprehensive analysis including:
        1. A summary of the most critical vulnerabilities discovered across all scans
        2. Consolidated vulnerability counts by severity
        3. Key attack vectors and potential exploit chains
        4. Most urgent remediation steps
        5. Recommended further testing or exploitation verification
        6. An overall security risk assessment based on the identified vulnerabilities
        
        Format your response as a detailed JSON object with these sections.
        """
        
        response = self._call_gemini(prompt)
        
        # Parse the JSON response
        try:
            # Extract JSON from the response text if needed
            json_start = response.find("{")
            json_end = response.rfind("}") + 1
            if json_start >= 0 and json_end > json_start:
                json_str = response[json_start:json_end]
                insights = json.loads(json_str)
            else:
                self.logger.warning("Could not extract JSON from insights response, using full response")
                insights = {"overall_analysis": response}
                
            return insights
        except json.JSONDecodeError:
            self.logger.error("Failed to parse LLM insights as JSON")
            return {
                "error": "Failed to parse LLM insights",
                "summary": "A comprehensive analysis could not be generated automatically.",
                "raw_insights": response[:1000] + "..." if len(response) > 1000 else response
            }

    def _get_default_targets(self, scanner_name: str, scan_targets: Dict[str, List[str]]) -> List[str]:
        """Get default targets for a specific scanner."""
        if scanner_name in ["nmap", "nuclei", "masscan"]:
            # Use IP addresses and domains for network scanners
            return scan_targets.get("ip_addresses", []) or scan_targets.get("domains", [])
        elif scanner_name in ["nikto", "zap", "sqlmap", "dirb", "gobuster", "xsser"]:
            # Use web servers for web scanners
            return scan_targets.get("web_servers", [])
        elif scanner_name == "wpscan":
            # WPScan only works on WordPress sites
            return [f"http://{domain}" for domain in scan_targets.get("domains", [])] + \
                   [f"https://{domain}" for domain in scan_targets.get("domains", [])]
        else:
            return []