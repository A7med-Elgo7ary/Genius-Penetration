#!/usr/bin/env python3
"""
Main script for the Vulnerability Scanning Agent.
"""

import os
import json
# import argparse # Removed argparse
import logging
from datetime import datetime
from typing import Dict, Any, List
import sys
# from flask import Flask, render_template, request, jsonify # Removed Flask

# Add the parent directory to sys.path
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

# Import environment variables loader
from utils.env_loader import load_environment_variables

# Import scanner modules
from agents.vulnerability_scanner_agent.scanners.nmap_wrapper import NmapScanner
from agents.vulnerability_scanner_agent.scanners.nikto_wrapper import NiktoScanner
from agents.vulnerability_scanner_agent.scanners.sqlmap_runner import SQLMapRunner
from agents.vulnerability_scanner_agent.scanners.wpscan import WPScanRunner
from agents.vulnerability_scanner_agent.scanners.dirb_gobuster import DirbRunner, GobusterRunner
from agents.vulnerability_scanner_agent.scanners.zap_wrapper import ZAPScanner
from agents.vulnerability_scanner_agent.scanners.nuclei_runner import NucleiScanner
from agents.vulnerability_scanner_agent.scanners.masscan_wrapper import MasscanScanner
from agents.vulnerability_scanner_agent.scanners.xsser_wrapper import XSSerScanner
from agents.vulnerability_scanner_agent.llm_interface import VulnScanLLMInterface

# app = Flask(__name__) # Removed Flask app initialization

class VulnerabilityScanningAgent:
    """Vulnerability Scanning Agent for detecting vulnerabilities in the target."""
    
    def __init__(self):
        """Initialize the Vulnerability Scanning Agent."""
        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(name)s] %(levelname)s: %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        self.logger = logging.getLogger("vulnerability_scanner_agent")
        
        # Load environment variables
        self.env_vars = load_environment_variables()
        
        # Initialize scanners with paths from environment variables
        self.scanners = {
            "nmap": NmapScanner(logger=self.logger),
            "nikto": NiktoScanner(nikto_path=self.env_vars.get('NIKTO_PATH', 'nikto'), logger=self.logger),
            "sqlmap": SQLMapRunner(sqlmap_path=self.env_vars.get('SQLMAP_PATH', 'sqlmap'), logger=self.logger),
            "wpscan": WPScanRunner(api_token=self.env_vars.get('WPSCAN_API_TOKEN'), logger=self.logger),
            "dirb": DirbRunner(dirb_path=self.env_vars.get('DIRB_PATH', 'dirb'), logger=self.logger),
            "gobuster": GobusterRunner(gobuster_path=self.env_vars.get('GOBUSTER_PATH', 'gobuster'), logger=self.logger),
            "zap": ZAPScanner(api_key=self.env_vars.get('ZAP_API_KEY'), logger=self.logger),
            "nuclei": NucleiScanner(nuclei_path=self.env_vars.get('NUCLEI_PATH', 'nuclei'), logger=self.logger),
            "masscan": MasscanScanner(masscan_path=self.env_vars.get('MASSCAN_PATH', 'masscan'), logger=self.logger),
            "xsser": XSSerScanner(xsser_path=self.env_vars.get('XSSER_PATH', 'xsser'), logger=self.logger)
        }
        
        # Initialize LLM interface
        api_key = self.env_vars.get('GEMINI_API_KEY')
        if not api_key:
            self.logger.warning("GEMINI_API_KEY not found in environment. LLM features will be disabled.")
            self.llm = None
        else:
            self.llm = VulnScanLLMInterface(api_key=api_key, logger=self.logger)
        
        self.output_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "output")
        os.makedirs(self.output_dir, exist_ok=True)
    
    def load_recon_data(self, recon_file_path: str) -> Dict[str, Any]:
        """
        Load reconnaissance data from the Reconnaissance Agent output.
        
        Args:
            recon_file_path: Path to the recon data JSON file
            
        Returns:
            Dict containing recon data
        """
        try:
            with open(recon_file_path, 'r') as f:
                recon_data = json.load(f)
            self.logger.info(f"Loaded reconnaissance data for target: {recon_data.get('target', 'unknown')}")
            return recon_data
        except Exception as e:
            self.logger.error(f"Error loading reconnaissance data from {recon_file_path}: {str(e)}")
            raise
    
    def extract_scan_targets(self, recon_data: Dict[str, Any]) -> Dict[str, List[str]]:
        """
        Extract scan targets from the reconnaissance data.
        
        Args:
            recon_data: Reconnaissance data
            
        Returns:
            Dict with lists of different target types (domains, IPs, etc.)
        """
        targets = {
            "main_target": recon_data.get("target", ""),
            "domains": [],
            "subdomains": [],
            "ip_addresses": [],
            "web_servers": []
        }
        
        # Extract data from DNSDumpster findings
        if "findings" in recon_data and "dnsdumpster" in recon_data["findings"]:
            dnsdumpster_data = recon_data["findings"]["dnsdumpster"]
            if isinstance(dnsdumpster_data, dict):
                if "hosts" in dnsdumpster_data:
                    for host in dnsdumpster_data["hosts"]:
                        if "ip" in host and host["ip"] not in targets["ip_addresses"]:
                            targets["ip_addresses"].append(host["ip"])
                        if "domain" in host and host["domain"] not in targets["domains"]:
                            targets["domains"].append(host["domain"])
        
        # Extract data from Sublist3r findings
        if "findings" in recon_data and "sublist3r" in recon_data["findings"]:
            sublist3r_data = recon_data["findings"]["sublist3r"]
            if isinstance(sublist3r_data, dict) and "subdomains" in sublist3r_data:
                for subdomain in sublist3r_data["subdomains"]:
                    if subdomain not in targets["subdomains"]:
                        targets["subdomains"].append(subdomain)
        
        # Extract web servers (assuming HTTP/HTTPS services)
        for domain in targets["domains"] + targets["subdomains"]:
            targets["web_servers"].append(f"http://{domain}")
            targets["web_servers"].append(f"https://{domain}")
        
        # Deduplicate
        for key in targets:
            if isinstance(targets[key], list):
                targets[key] = list(set(targets[key]))
        
        self.logger.info(f"Extracted scan targets: {json.dumps(targets, indent=2)}")
        return targets

    def run(self, recon_file_path: str = None, target: str = None) -> Dict[str, Any]:
        """
        Run vulnerability scanning on the target.
        
        Args:
            recon_file_path: Path to the recon data JSON file (optional)
            target: Target domain to scan (optional, used if no recon data)
            
        Returns:
            Dict containing vulnerability scan results
        """
        # Initialize scan results
        results = {
            "scan_date": datetime.utcnow().isoformat(),
            "target": target,
            "findings": {},
            "total_vulnerabilities": 0,
            "critical_vulnerabilities": 0,
            "high_vulnerabilities": 0,
            "medium_vulnerabilities": 0,
            "low_vulnerabilities": 0
        }
        
        # Load reconnaissance data if provided
        recon_data = None
        scan_targets = {}
        
        if recon_file_path:
            recon_data = self.load_recon_data(recon_file_path)
            results["target"] = recon_data.get("target", target)
            scan_targets = self.extract_scan_targets(recon_data)
        elif target:
            scan_targets = {
                "main_target": target,
                "domains": [target],
                "subdomains": [],
                "ip_addresses": [],
                "web_servers": [f"http://{target}", f"https://{target}"]
            }
        else:
            self.logger.error("No target or recon data provided")
            raise ValueError("Either recon_file_path or target must be provided")
        
        self.logger.info(f"Starting vulnerability scanning on target: {results['target']}")
        
        # Get scan strategy from LLM if available
        if self.llm:
            try:
                strategy = self.llm.determine_scan_strategy(
                    scan_targets=scan_targets,
                    available_scanners=list(self.scanners.keys()),
                    recon_data=recon_data
                )
                self.logger.info(f"LLM Strategy: {json.dumps(strategy, indent=2)}")
                
                scanner_order = strategy["scanner_order"]
                scanner_configs = strategy["scanner_configs"]
            except Exception as e:
                self.logger.error(f"Error getting LLM strategy: {str(e)}")
                scanner_order = list(self.scanners.keys())
                scanner_configs = {scanner: {} for scanner in scanner_order}
        else:
            scanner_order = list(self.scanners.keys())
            scanner_configs = {scanner: {} for scanner in scanner_order}
        
        # Run each scanner in the determined order
        for scanner_name in scanner_order:
            if scanner_name not in self.scanners or not self.scanners[scanner_name].available:
                self.logger.warning(f"Scanner {scanner_name} is not available, skipping")
                continue
            
            scanner = self.scanners[scanner_name]
            scanner_config = scanner_configs.get(scanner_name, {})
            
            # Get targets for this scanner
            scanner_targets = scanner_config.get("targets", [])
            if not scanner_targets:
                scanner_targets = self._get_default_targets(scanner_name, scan_targets)
            
            if not scanner_targets:
                self.logger.warning(f"No targets for {scanner_name}, skipping")
                continue
            
            self.logger.info(f"Running {scanner_name} scanner against: {scanner_targets}")
            
            try:
                # Use LLM to assist with scanner execution if available
                scanner_results = None
                if self.llm:
                    try:
                        prompt = self.llm.generate_scanner_prompt(
                            scanner_name=scanner_name,
                            scan_targets=scanner_targets,
                            scanner_config=scanner_config
                        )
                        scanner_results = self.llm.execute_scanner(
                            scanner_name=scanner_name,
                            scan_targets=scanner_targets,
                            prompt=prompt,
                            scanner_instance=scanner
                        )
                    except Exception as e:
                        self.logger.error(f"Error using LLM for {scanner_name}: {str(e)}")
                        scanner_results = scanner.scan(scanner_targets)
                else:
                    scanner_results = scanner.scan(scanner_targets)
                
                results["findings"][scanner_name] = scanner_results
                
                # Count vulnerabilities
                if self.llm:
                    try:
                        analyzed_results = self.llm.process_scanner_output(
                            scanner_name=scanner_name,
                            scanner_output=scanner_results,
                            scan_targets=scanner_targets
                        )
                        
                        # Update vulnerability counts
                        if "vulnerability_counts" in analyzed_results:
                            counts = analyzed_results["vulnerability_counts"]
                            results["critical_vulnerabilities"] += counts.get("critical", 0)
                            results["high_vulnerabilities"] += counts.get("high", 0)
                            results["medium_vulnerabilities"] += counts.get("medium", 0)
                            results["low_vulnerabilities"] += counts.get("low", 0)
                            
                        results["findings"][scanner_name] = analyzed_results
                    except Exception as e:
                        self.logger.error(f"Error analyzing {scanner_name} results with LLM: {str(e)}")
                        
                        # Basic vulnerability counting
                        if isinstance(scanner_results, dict) and "vulnerabilities" in scanner_results:
                            results["total_vulnerabilities"] += len(scanner_results["vulnerabilities"])
                
                self.logger.info(f"Completed {scanner_name} scan")
                
            except Exception as e:
                self.logger.error(f"Error running {scanner_name}: {str(e)}")
                results["findings"][scanner_name] = {"error": str(e)}
        
        # Update total vulnerabilities
        results["total_vulnerabilities"] = (
            results["critical_vulnerabilities"] +
            results["high_vulnerabilities"] +
            results["medium_vulnerabilities"] +
            results["low_vulnerabilities"]
        )
        
        # If LLM is available, perform final analysis of all results
        if self.llm:
            try:
                final_analysis = self.llm.analyze_scan_data(results, scan_targets)
                results["llm_analysis"] = final_analysis
            except Exception as e:
                self.logger.error(f"Error performing final LLM analysis: {str(e)}")
        
        # Save results
        output_file = os.path.join(self.output_dir, "vuln_scan_results.json")
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=4)
            
        # Log summary
        self.logger.info(f"Vulnerability scanning complete. Summary:")
        self.logger.info(f"- Critical vulnerabilities: {results['critical_vulnerabilities']}")
        self.logger.info(f"- High vulnerabilities: {results['high_vulnerabilities']}")
        self.logger.info(f"- Medium vulnerabilities: {results['medium_vulnerabilities']}")
        self.logger.info(f"- Low vulnerabilities: {results['low_vulnerabilities']}")
        self.logger.info(f"- Total vulnerabilities: {results['total_vulnerabilities']}")
        self.logger.info(f"Results saved to {output_file}")
        
        return results
    
    def _get_default_targets(self, scanner_name: str, scan_targets: Dict[str, List[str]]) -> List[str]:
        """Get default targets for a specific scanner."""
        if scanner_name in ["nmap", "nuclei"]:
            # Use IP addresses and domains for network scanners
            return scan_targets.get("ip_addresses", []) or scan_targets.get("domains", [])
        elif scanner_name == "masscan":
            # Masscan works best with IP addresses only
            return scan_targets.get("ip_addresses", []) or scan_targets.get("domains", [])
        elif scanner_name in ["nikto", "zap", "sqlmap", "dirb", "gobuster"]:
            # Use web servers for web scanners
            return scan_targets.get("web_servers", [])
        elif scanner_name == "wpscan":
            # WPScan only works on WordPress sites
            return [f"http://{domain}" for domain in scan_targets.get("domains", [])] + \
                   [f"https://{domain}" for domain in scan_targets.get("domains", [])]
        elif scanner_name == "xsser":
            # XSSerScanner primarily targets web applications
            return scan_targets.get("web_servers", []) or [
                f"http://{domain}" for domain in scan_targets.get("domains", [])
            ]
        else:
            # Default: use main target
            return [scan_targets.get("main_target")] if scan_targets.get("main_target") else []

def main():
    """Main entry point."""
    # Hardcode the recon file path
    recon_file_path = "/home/kali/Desktop/Genius-Penetration/agents/reconnaissance_agent/output/recon_data.json"
    
    agent = VulnerabilityScanningAgent()
    # Use the hardcoded recon file path
    results = agent.run(recon_file_path=recon_file_path, target=None)
    print(json.dumps(results, indent=2))

if __name__ == "__main__":
    main()
