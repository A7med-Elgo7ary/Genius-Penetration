#!/usr/bin/env python3
"""
Main script for the Vulnerability Scanning Agent.
"""

import os
import json
# import argparse # Removed argparse
import logging
from datetime import datetime
from typing import Dict, Any, List
import sys
# from flask import Flask, render_template, request, jsonify # Removed Flask

# Add the parent directory to sys.path
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from agents.vulnerability_scanner_agent.scanners.nmap_wrapper import NmapScanner
from agents.vulnerability_scanner_agent.scanners.nikto_wrapper import NiktoScanner
from agents.vulnerability_scanner_agent.scanners.sqlmap_runner import SQLMapRunner
from agents.vulnerability_scanner_agent.scanners.wpscan import WPScanRunner
from agents.vulnerability_scanner_agent.scanners.dirb_gobuster import DirbRunner, GobusterRunner
from agents.vulnerability_scanner_agent.scanners.zap_wrapper import ZAPScanner
from agents.vulnerability_scanner_agent.scanners.nuclei_runner import NucleiScanner
from agents.vulnerability_scanner_agent.scanners.masscan_wrapper import MasscanScanner
from agents.vulnerability_scanner_agent.scanners.xsser_wrapper import XSSerScanner
from agents.vulnerability_scanner_agent.llm_interface import VulnScanLLMInterface

# app = Flask(__name__) # Removed Flask app initialization

class VulnerabilityScanningAgent:
    """Vulnerability Scanning Agent for detecting vulnerabilities in the target."""
    
    def __init__(self):
        """Initialize the Vulnerability Scanning Agent."""
        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(name)s] %(levelname)s: %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        self.logger = logging.getLogger("vulnerability_scanner_agent")
        
        # Initialize scanners
        self.scanners = {
            "nmap": NmapScanner(),
            "nikto": NiktoScanner(),
            "sqlmap": SQLMapRunner(),
            "wpscan": WPScanRunner(),
            "dirb": DirbRunner(),
            "gobuster": GobusterRunner(),
            "zap": ZAPScanner(),
            "nuclei": NucleiScanner(),
            "masscan": MasscanScanner(),
            "xsser": XSSerScanner()
        }
        
        # Initialize LLM interface
        api_key = os.getenv('GEMINI_API_KEY')
        if not api_key:
            self.logger.warning("GEMINI_API_KEY not found in environment. LLM features will be disabled.")
            self.llm = None
        else:
            self.llm = VulnScanLLMInterface(api_key=api_key, logger=self.logger)
        
        self.output_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "output")
        os.makedirs(self.output_dir, exist_ok=True)
    
    def load_recon_data(self, recon_file_path: str) -> Dict[str, Any]:
        """
        Load reconnaissance data from the Reconnaissance Agent output.
        
        Args:
            recon_file_path: Path to the recon data JSON file
            
        Returns:
            Dict containing recon data
        """
        try:
            with open(recon_file_path, 'r') as f:
                recon_data = json.load(f)
            self.logger.info(f"Loaded reconnaissance data for target: {recon_data.get('target', 'unknown')}")
            return recon_data
        except Exception as e:
            self.logger.error(f"Error loading reconnaissance data: {str(e)}")
            raise
    
    def extract_scan_targets(self, recon_data: Dict[str, Any]) -> Dict[str, List[str]]:
        """
        Extract scan targets from the reconnaissance data.
        
        Args:
            recon_data: Reconnaissance data
            
        Returns:
            Dict with lists of different target types (domains, IPs, etc.)
        """
        targets = {
            "main_target": recon_data.get("target", ""),
            "domains": [],
            "subdomains": [],
            "ip_addresses": [],
            "web_servers": []
        }
        
        # Extract data from DNSDumpster findings
        if "findings" in recon_data and "dnsdumpster" in recon_data["findings"]:
            dnsdumpster_data = recon_data["findings"]["dnsdumpster"]
            if isinstance(dnsdumpster_data, dict):
                if "hosts" in dnsdumpster_data:
                    for host in dnsdumpster_data["hosts"]:
                        if "ip" in host and host["ip"] not in targets["ip_addresses"]:
                            targets["ip_addresses"].append(host["ip"])
                        if "domain" in host and host["domain"] not in targets["domains"]:
                            targets["domains"].append(host["domain"])
        
        # Extract data from Sublist3r findings
        if "findings" in recon_data and "sublist3r" in recon_data["findings"]:
            sublist3r_data = recon_data["findings"]["sublist3r"]
            if isinstance(sublist3r_data, dict) and "subdomains" in sublist3r_data:
                for subdomain in sublist3r_data["subdomains"]:
                    if subdomain not in targets["subdomains"]:
                        targets["subdomains"].append(subdomain)
        
        # Extract web servers (assuming HTTP/HTTPS services)
        for domain in targets["domains"] + targets["subdomains"]:
            targets["web_servers"].append(f"http://{domain}")
            targets["web_servers"].append(f"https://{domain}")
        
        # Deduplicate
        for key in targets:
            if isinstance(targets[key], list):
                targets[key] = list(set(targets[key]))
        
        self.logger.info(f"Extracted scan targets: {json.dumps(targets, indent=2)}")
        return targets
    
    def run(self, recon_file_path: str = None, target: str = None) -> Dict[str, Any]:
        """
        Run vulnerability scanning on the target.
        
        Args:
            recon_file_path: Path to the recon data JSON file (optional)
            target: Target domain to scan (optional, used if no recon data)
            
        Returns:
            Dict containing vulnerability scan results
        """
        # Initialize scan results
        results = {
            "scan_date": datetime.utcnow().isoformat(),
            "target": target,
            "findings": {},
            "total_vulnerabilities": 0,
            "critical_vulnerabilities": 0,
            "high_vulnerabilities": 0,
            "medium_vulnerabilities": 0,
            "low_vulnerabilities": 0
        }
        
        # Load reconnaissance data if provided
        recon_data = None
        scan_targets = {}
        
        if recon_file_path:
            recon_data = self.load_recon_data(recon_file_path)
            results["target"] = recon_data.get("target", target)
            scan_targets = self.extract_scan_targets(recon_data)
        elif target:
            scan_targets = {
                "main_target": target,
                "domains": [target],
                "subdomains": [],
                "ip_addresses": [],
                "web_servers": [f"http://{target}", f"https://{target}"]
            }
        else:
            self.logger.error("No target or recon data provided")
            raise ValueError("Either recon_file_path or target must be provided")
        
        self.logger.info(f"Starting vulnerability scanning on target: {results['target']}")
        
        # Get scan strategy from LLM if available
        if self.llm:
            try:
                strategy = self.llm.determine_scan_strategy(
                    scan_targets=scan_targets,
                    available_scanners=list(self.scanners.keys()),
                    recon_data=recon_data
                )
                self.logger.info(f"LLM Strategy: {json.dumps(strategy, indent=2)}")
                
                scanner_order = strategy["scanner_order"]
                scanner_configs = strategy["scanner_configs"]
            except Exception as e:
                self.logger.error(f"Error getting LLM strategy: {str(e)}")
                scanner_order = list(self.scanners.keys())
                scanner_configs = {scanner: {} for scanner in scanner_order}
        else:
            scanner_order = list(self.scanners.keys())
            scanner_configs = {scanner: {} for scanner in scanner_order}
        
        # Run each scanner in the determined order
        for scanner_name in scanner_order:
            scanner = self.scanners[scanner_name]
            try:
                self.logger.info(f"Running {scanner_name} scan...")
                
                # Get scanner-specific targets and configuration
                scanner_config = scanner_configs.get(scanner_name, {})
                scanner_targets = scanner_config.get("targets", self._get_default_targets(scanner_name, scan_targets))
                
                # If LLM is available, get scanner-specific guidance
                if self.llm:
                    try:
                        prompt = self.llm.generate_scanner_prompt(
                            scanner_name=scanner_name,
                            scan_targets=scanner_targets,
                            scanner_config=scanner_config
                        )
                        scanner_results = self.llm.execute_scanner(
                            scanner_name=scanner_name,
                            scan_targets=scanner_targets,
                            prompt=prompt,
                            scanner_instance=scanner
                        )
                    except Exception as e:
                        self.logger.error(f"Error using LLM for {scanner_name}: {str(e)}")
                        scanner_results = scanner.scan(scanner_targets)
                else:
                    scanner_results = scanner.scan(scanner_targets)
                
                results["findings"][scanner_name] = scanner_results
                
                # Count vulnerabilities
                if self.llm:
                    try:
                        analyzed_results = self.llm.process_scanner_output(
                            scanner_name=scanner_name,
                            scanner_output=scanner_results,
                            scan_targets=scanner_targets
                        )
                        
                        # Update vulnerability counts
                        if "vulnerability_counts" in analyzed_results:
                            counts = analyzed_results["vulnerability_counts"]
                            results["critical_vulnerabilities"] += counts.get("critical", 0)
                            results["high_vulnerabilities"] += counts.get("high", 0)
                            results["medium_vulnerabilities"] += counts.get("medium", 0)
                            results["low_vulnerabilities"] += counts.get("low", 0)
                            
                        results["findings"][scanner_name] = analyzed_results
                    except Exception as e:
                        self.logger.error(f"Error analyzing {scanner_name} results with LLM: {str(e)}")
                        
                        # Basic vulnerability counting
                        if isinstance(scanner_results, dict) and "vulnerabilities" in scanner_results:
                            results["total_vulnerabilities"] += len(scanner_results["vulnerabilities"])
                
                self.logger.info(f"Completed {scanner_name} scan")
                
            except Exception as e:
                self.logger.error(f"Error running {scanner_name}: {str(e)}")
                results["findings"][scanner_name] = {"error": str(e)}
        
        # Update total vulnerabilities
        results["total_vulnerabilities"] = (
            results["critical_vulnerabilities"] +
            results["high_vulnerabilities"] +
            results["medium_vulnerabilities"] +
            results["low_vulnerabilities"]
        )
        
        # If LLM is available, perform final analysis of all results
        if self.llm:
            try:
                final_analysis = self.llm.analyze_scan_data(results, scan_targets)
                results["llm_analysis"] = final_analysis
            except Exception as e:
                self.logger.error(f"Error performing final LLM analysis: {str(e)}")
        
        # Save results
        output_file = os.path.join(self.output_dir, "vuln_scan_results.json")
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=4)
            
        # Log summary
        self.logger.info(f"Vulnerability scanning complete. Summary:")
        self.logger.info(f"- Critical vulnerabilities: {results['critical_vulnerabilities']}")
        self.logger.info(f"- High vulnerabilities: {results['high_vulnerabilities']}")
        self.logger.info(f"- Medium vulnerabilities: {results['medium_vulnerabilities']}")
        self.logger.info(f"- Low vulnerabilities: {results['low_vulnerabilities']}")
        self.logger.info(f"- Total vulnerabilities: {results['total_vulnerabilities']}")
        self.logger.info(f"Results saved to {output_file}")
        
        return results
    
    def _get_default_targets(self, scanner_name: str, scan_targets: Dict[str, List[str]]) -> List[str]:
        """Get default targets for a specific scanner."""
        if scanner_name in ["nmap", "nuclei"]:
            # Use IP addresses and domains for network scanners
            return scan_targets.get("ip_addresses", []) or scan_targets.get("domains", [])
        elif scanner_name in ["nikto", "zap", "sqlmap", "dirb", "gobuster"]:
            # Use web servers for web scanners
            return scan_targets.get("web_servers", [])
        elif scanner_name == "wpscan":
            # WPScan only works on WordPress sites
            return [f"http://{domain}" for domain in scan_targets.get("domains", [])] + \
                   [f"https://{domain}" for domain in scan_targets.get("domains", [])]
        else:
            # Default: use main target
            return [scan_targets.get("main_target")] if scan_targets.get("main_target") else []

# Removed Flask routes
# @app.route('/')
# def index():
#     return render_template('vuln_scan_page.html')

# @app.route('/scan', methods=['POST'])
# def scan():
#     target = request.form.get('target')
#     recon_file = request.form.get('recon_file')
    
#     if not target and not recon_file:
#         return render_template('vuln_scan_page.html', message="Please provide a target or recon file path.", error=True)

#     try:
#         agent = VulnerabilityScanningAgent()
#         results = agent.run(recon_file_path=recon_file, target=target)
#         message = f"Vulnerability scanning completed successfully!"
#         message += f"\nFound {results['total_vulnerabilities']} vulnerabilities:"
#         message += f"\n- Critical: {results['critical_vulnerabilities']}"
#         message += f"\n- High: {results['high_vulnerabilities']}"
#         message += f"\n- Medium: {results['medium_vulnerabilities']}"
#         message += f"\n- Low: {results['low_vulnerabilities']}"
#         if "llm_analysis" in results and "summary" in results["llm_analysis"]:
#             message += f"\n\nLLM Analysis Summary: {results['llm_analysis']['summary']}"
#         message += "\n\nResults saved to output/vuln_scan_results.json"
#         return render_template('vuln_scan_page.html', message=message)
#     except Exception as e:
#         return render_template('vuln_scan_page.html', message=f"Error during vulnerability scanning: {str(e)}", error=True)

def main():
    """Main entry point."""
    # Removed argument parsing
    # parser = argparse.ArgumentParser(description="Vulnerability Scanning Agent")
    # parser.add_argument("-t", "--target", help="Target domain for vulnerability scanning")
    # parser.add_argument("-r", "--recon", help="Path to reconnaissance data JSON file")
    # parser.add_argument("--web", action="store_true", help="Start web interface")
    # args = parser.parse_args()

    # Hardcode the recon file path
    recon_file_path = "/home/kali/Desktop/genius_penetration/agents/reconnaissance_agent/output/recon_data.json"
    
    # Removed web interface logic
    # if args.web:
    #     app.run(debug=True, port=5051)
    # elif args.target or args.recon:
    agent = VulnerabilityScanningAgent()
    # Use the hardcoded recon file path
    results = agent.run(recon_file_path=recon_file_path, target=None)
    print(json.dumps(results, indent=2))
    # else:
    #     app.run(debug=True, port=5051)

if __name__ == "__main__":
    main()