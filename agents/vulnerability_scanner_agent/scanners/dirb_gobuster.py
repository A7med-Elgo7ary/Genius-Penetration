#!/usr/bin/env python3
"""
Wrappers for Dirb and Gobuster directory/file brute-forcing tools.
"""

import subprocess
import os
import logging
from typing import List, Dict, Any, Optional, Tuple
import re

class DirbRunner:
    """Wrapper for the Dirb directory/file scanner."""

    def __init__(self, dirb_path: str = "dirb", logger: Optional[logging.Logger] = None):
        """
        Initialize the Dirb runner.

        Args:
            dirb_path: Path to the dirb executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("dirb_runner")
        self.dirb_path = dirb_path
        self.default_wordlist = "/usr/share/dirb/wordlists/common.txt" # Common default on Kali
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if Dirb is installed."""
        try:
            # Check if dirb exists at the standard system path
            if os.path.exists('/usr/bin/dirb'):
                self.dirb_path = '/usr/bin/dirb'
                self.logger.info(f"Using system Dirb at {self.dirb_path}")
                
            # Dirb doesn't have a simple --version. It prints help if no args.
            result = subprocess.run([self.dirb_path], capture_output=True, text=True, timeout=10)
            combined_output = result.stdout + result.stderr
            
            # Look for characteristic output in Dirb's help message
            if "DIRB" in combined_output:
                self.logger.info(f"Dirb found at {self.dirb_path}")
                return True
            else:
                self.logger.warning(f"Dirb not behaving as expected at {self.dirb_path}. Output: {combined_output[:200]}")
                return False
        except FileNotFoundError:
            self.logger.error(f"Dirb executable not found at {self.dirb_path}. Please install Dirb.")
            return False
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout checking Dirb availability at {self.dirb_path}.")
            return False
        except Exception as e:
            self.logger.error(f"Error checking Dirb availability: {e}")
            return False

    def _parse_dirb_output(self, output_text: str, base_url: str) -> List[Dict[str, Any]]:
        """
        Parse Dirb's text output.
        Example lines:
        + http://example.com/found_dir/ (CODE:200|SIZE:1234)
        ==> DIRECTORY: http://example.com/another_dir/
        """
        found_items = []
        # Ensure base_url ends with a slash if it's likely a directory context for joining
        if not base_url.endswith('/') and '.' not in base_url.split('/')[-1]:
            base_url += '/'

        for line in output_text.splitlines():
            line = line.strip()
            if line.startswith("+ ") or line.startswith("==> DIRECTORY:"):
                path = ""
                code = None
                size = None
                is_directory = line.startswith("==> DIRECTORY:")

                if is_directory:
                    match = re.search(r"DIRECTORY:\s*(.*)", line)
                    if match:
                        path = match.group(1).strip()
                else: # Starts with "+ "
                    match = re.search(r"\+\s*(.*?)\s*\(CODE:(\d+)\|SIZE:(\S+)\)", line)
                    if match:
                        path = match.group(1).strip()
                        code = int(match.group(2))
                        size_str = match.group(3)
                        try:
                            size = int(size_str) if size_str.isdigit() else None
                        except ValueError:
                            size = None # Or keep as string if needed
                
                if path:
                    # Ensure full URL. Dirb sometimes gives full, sometimes relative.
                    full_url = path if path.startswith("http") else (base_url.rstrip('/') + '/' + path.lstrip('/'))
                    # A simple way to normalize multiple slashes, though urljoin is more robust
                    full_url = full_url.replace('//', '/').replace(':/', '://')


                    found_items.append({
                        "url": full_url,
                        "status_code": code,
                        "size": size,
                        "type": "directory" if is_directory or (code and full_url.endswith('/')) else "file"
                    })
        return found_items

    def scan(self, base_url: str, wordlist: Optional[str] = None,
             extensions: Optional[List[str]] = None, # e.g., [".php", ".html"]
             recursive: bool = False,
             additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run Dirb against a base URL.

        Args:
            base_url: The base URL to scan (e.g., "http://example.com/").
            wordlist: Path to the wordlist file. Uses default if None.
            extensions: List of file extensions to check (e.g., [".php", ".html"]).
            recursive: Whether to scan recursively for directories.
            additional_args: List of additional Dirb arguments.

        Returns:
            Dict containing scan results.
        """
        if not self.available:
            return {"error": "Dirb scanner not available."}

        actual_wordlist = wordlist or self.default_wordlist
        
        if not os.path.exists(actual_wordlist):
            self.logger.error(f"Dirb wordlist not found: {actual_wordlist}")
            return {"error": f"Dirb wordlist not found: {actual_wordlist}"}

        results: Dict[str, Any] = {
            "base_url": base_url,
            "wordlist_used": actual_wordlist,
            "found_paths": [],
            "error": None,
            "command_used": ""
        }

        output_file = tempfile.NamedTemporaryFile(delete=False, mode='w+', suffix='.txt').name
        
        cmd = [self.dirb_path, base_url, actual_wordlist]

        if extensions:
            ext_string = ",".join([e if e.startswith('.') else '.' + e for e in extensions])
            cmd.extend(["-x", ext_string])

        if not recursive:
            cmd.append("-r")

              # if set to False, use -r (non-recursive after initial find)
            # This logic is a bit tricky due to Dirb's -r flag meaning "Do not recurse into found subdirectories".
            # Most users expect "recursive=True" to mean "go deep". Dirb does this by default.
            # If recursive=False, then add -r to limit recursion.
            # The variable name `recursive` might be misleading here.
            # Let's assume user wants non-recursive only if they explicitly set `recursive=False`.
            # The parameter `recursive: bool = False` means by default it *is* recursive.
            # If they pass `recursive=True` it means they want the default.
            # If they pass `recursive=False` it means they want `-r`.
            # To make it clearer: if `recursive` (parameter) is True, do nothing (default Dirb).
            # If `recursive` (parameter) is False, add `-r` to Dirb.
            # The current default `recursive: bool = False` means if user doesn't specify, it will add `-r`.
            # This is opposite of what's intuitive. Let's adjust:
            # `recursive: bool = True` means it IS recursive by default.
            # If user passes `recursive=False`, then we add `-r`.
            if not recursive: # If `recursive` parameter is False
                 cmd.append("-r") # Add Dirb's non-recursive flag
        
        if additional_args:
            cmd.extend(additional_args)
        
        results["command_used"] = " ".join(cmd)
        self.logger.info(f"Running Dirb command: {results['command_used']}")

        try:
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, errors='replace')
            stdout, stderr = process.communicate(timeout=timeout_seconds)

            if stderr:
                self.logger.warning(f"Dirb stderr: {stderr.strip()}")
                if "could not" in stderr.lower() or "error" in stderr.lower():
                    results["error"] = stderr.strip()

            if process.returncode != 0 and not results["error"]:
                results["error"] = f"Dirb process exited with code {process.returncode}. Stderr: {stderr.strip()}"

            # Check if we saved output to a file
            if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
                with open(output_file, 'r', errors='replace') as f:
                    output_content = f.read()
                
                results["found_paths"] = self._parse_dirb_output(output_content, base_url)
                self.logger.info(f"Parsed {len(results['found_paths'])} results from Dirb output file")
            # Fallback to stdout if output file is empty or doesn't exist
            elif stdout:
                results["found_paths"] = self._parse_dirb_output(stdout, base_url)
                self.logger.info(f"Parsed {len(results['found_paths'])} results from Dirb stdout")
            else:
                self.logger.warning("No Dirb output found in file or stdout.")
                if not results["error"]:
                    results["error"] = "No output from Dirb scan."
            
            # Clean up temporary file
            try:
                if os.path.exists(output_file):
                    os.unlink(output_file)
            except Exception as e:
                self.logger.warning(f"Failed to delete temporary file {output_file}: {e}")
                
            return results
        except subprocess.TimeoutExpired:
            self.logger.error(f"Dirb scan timed out for base_url: {base_url}")
            results["error"] = "Dirb scan timed out."
            # Try to parse any stdout obtained before timeout
            if 'stdout' in locals() and stdout:
                 results["found_paths"] = self._parse_dirb_output(stdout, base_url)
            return results
        except Exception as e:
            self.logger.error(f"Error running Dirb scan: {e}")
            results["error"] = str(e)
            return results

class GobusterRunner:
    """Wrapper for the Gobuster tool (specifically 'dir' mode)."""

    def __init__(self, gobuster_path: str = "gobuster", logger: Optional[logging.Logger] = None):
        """
        Initialize the Gobuster runner.

        Args:
            gobuster_path: Path to the gobuster executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("gobuster_runner")
        self.gobuster_path = gobuster_path
        self.default_wordlist = "/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt" # Common default
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if Gobuster is installed."""
        try:
            # Check if gobuster exists at the specified path
            if os.path.exists('/usr/bin/gobuster'):
                self.gobuster_path = '/usr/bin/gobuster'
                self.logger.info(f"Using system Gobuster at {self.gobuster_path}")
            
            # Use the 'version' command instead of --version flag
            result = subprocess.run([self.gobuster_path, "version"], capture_output=True, text=True, timeout=10)
            combined_output = result.stdout + result.stderr
            
            # Gobuster outputs version info to stdout
            if "Gobuster" in combined_output or "version" in combined_output.lower():
                self.logger.info(f"Gobuster found at {self.gobuster_path}: {result.stdout.strip()}")
                return True
            
            # Try running without arguments to see if it works
            result = subprocess.run([self.gobuster_path], capture_output=True, text=True, timeout=10)
            combined_output = result.stdout + result.stderr
            
            if "Available Commands:" in combined_output and "dir" in combined_output:
                self.logger.info(f"Gobuster found at {self.gobuster_path}")
                return True
            
            self.logger.warning(f"Gobuster not behaving as expected at {self.gobuster_path}. Output: {combined_output[:200]}")
            return False
        except FileNotFoundError:
            self.logger.error(f"Gobuster executable not found at {self.gobuster_path}. Please install Gobuster.")
            return False
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout checking Gobuster availability at {self.gobuster_path}.")
            return False
        except Exception as e:
            self.logger.error(f"Error checking Gobuster availability: {e}")
            return False

    def _parse_gobuster_output(self, output_text: str, base_url: str) -> List[Dict[str, Any]]:
        """
        Parse Gobuster's text output for 'dir' mode.
        Modern Gobuster outputs formats like:
        /admin                (Status: 301) [Size: 169] [--> /admin/]
        /js                   (Status: 301) [Size: 169] [--> /js/]
        /css                  (Status: 301) [Size: 169] [--> /css/]
        
        Or when using quiet mode (-q):
        /admin
        /js
        /css
        
        This parser handles both formats and extracts all available information.
        """
        found_items = []
        # Ensure base_url ends with a slash for proper joining if it's a directory URL
        if not base_url.endswith('/') and '.' not in base_url.split('/')[-1]:
            base_url += '/'

        for line in output_text.splitlines():
            line = line.strip()
            # Skip empty lines, comments, progress bars, etc.
            if not line or line.startswith("#") or line.startswith("Progress:") \
               or "Gobuster" in line or "Starting" in line or "Finished" in line \
               or "===============" in line:
                continue

            item = {}
            
            # Try different Gobuster output formats
            # Format 1: Modern Gobuster with status and size: "/path (Status: 200) [Size: 1234]"
            status_match = re.search(r'\(Status:\s*(\d+)\)', line)
            if status_match:
                item['status_code'] = int(status_match.group(1))
            
            # Extract size if present
            size_match = re.search(r'\[Size:\s*(\d+)\]', line)
            if size_match:
                item['size'] = int(size_match.group(1))
            
            # Extract redirect if present
            redirect_match = re.search(r'\[-->\s*(.+?)\]', line)
            if redirect_match:
                item['redirect'] = redirect_match.group(1).strip()
            
            # Extract the path - take the first part of the line before any whitespace or parenthesis
            path_match = re.search(r'^\s*([^\s\(]+)', line)
            if path_match:
                path = path_match.group(1).strip()
                
                # Ensure path starts with /
                if not path.startswith('/'):
                    path = '/' + path
                    
                # Build the full URL
                full_url = base_url.rstrip('/') + path
                
                # Normalize slashes (avoid double slashes except in protocol)
                full_url = re.sub(r'(?<!:)//+', '/', full_url)
                
                item['url'] = full_url
                item['path'] = path
                item['type'] = 'directory' if path.endswith('/') or (item.get('redirect') and item['redirect'].endswith('/')) else 'file'
                
                found_items.append(item)
                
        return found_items

    def scan(self, base_url: str, wordlist: Optional[str] = None,
             extensions: Optional[List[str]] = None, # File extensions to check
             status_codes: Optional[str] = "200,204,301,302,307,401,403", # Default good codes
             threads: int = 10,
             quiet: bool = False, # -q for less verbose output
             additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run Gobuster 'dir' mode scan.

        Args:
            base_url: The base URL to scan (e.g., "http://example.com").
            wordlist: Path to the wordlist file. Uses default if None.
            extensions: List of file extensions to check (e.g., ["php", "html", "txt"]).
            status_codes: Comma-separated list of status codes to report (default: 200,204,301,302,307,401,403).
            threads: Number of concurrent threads.
            quiet: Less verbose output.
            additional_args: List of additional gobuster arguments.

        Returns:
            Dict containing scan results.
        """
        if not self.available:
            return {"error": "Gobuster scanner not available."}

        results: Dict[str, Any] = {
            "base_url": base_url,
            "found_paths": [],
            "error": None,
            "command_used": ""
        }

        # Create a temporary file for output
        output_file = tempfile.NamedTemporaryFile(delete=False, mode='w+', suffix='.txt').name

        # Use the specified wordlist or default if None
        actual_wordlist = wordlist or self.default_wordlist
        
        cmd = [self.gobuster_path, "dir", "-u", base_url, "-w", actual_wordlist]

        # Add extensions if specified
        if extensions:
            cmd.extend(["-x", ",".join(extensions)])

        # Add status code filter if specified
        if status_codes:
            cmd.extend(["-s", status_codes])

        # Add thread count
        cmd.extend(["-t", str(threads)])

        # Add quiet mode if specified
        if quiet:
            cmd.append("-q")
        else: # If not quiet, good to have --no-progress for cleaner logs in automation
            cmd.append("--no-progress")


        if additional_args:
            cmd.extend(additional_args)
        
        results["command_used"] = " ".join(cmd)
        self.logger.info(f"Running Gobuster command: {results['command_used']}")

        try:
            # Run gobuster with output going to the file
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, errors='replace')
            stdout, stderr = process.communicate(timeout=1800) # 30-minute timeout

            if stderr and not stderr.strip().startswith('Error:') and "error:" not in stderr.lower():
                self.logger.warning(f"Gobuster stderr: {stderr.strip()}")
                if "error" in stderr.lower() or "panic" in stderr.lower():
                    results["error"] = stderr.strip()
            
            if process.returncode != 0 and not results["error"]:
                results["error"] = f"Gobuster process exited with code {process.returncode}. Stderr: {stderr.strip()}"
            
            # Check if output file was created and has content
            if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
                with open(output_file, 'r') as f:
                    output_content = f.read()
                results["found_paths"] = self._parse_gobuster_output(output_content, base_url)
                self.logger.info(f"Parsed {len(results['found_paths'])} results from Gobuster output file")
            # Fallback to stdout if output file is empty or doesn't exist
            elif stdout:
                results["found_paths"] = self._parse_gobuster_output(stdout, base_url)
                self.logger.info(f"Parsed {len(results['found_paths'])} results from Gobuster stdout")
            else:
                self.logger.warning("No Gobuster results found in output file or stdout")
            
            # Clean up temporary file
            try:
                if os.path.exists(output_file):
                    os.unlink(output_file)
            except Exception as e:
                self.logger.warning(f"Failed to delete temporary file {output_file}: {e}")
            
            return results

        except subprocess.TimeoutExpired:
            self.logger.error(f"Gobuster scan timed out for base_url: {base_url}")
            results["error"] = "Gobuster scan timed out."
            if 'stdout' in locals() and stdout: # Check if stdout was captured before timeout
                 results["found_paths"] = self._parse_gobuster_output(stdout, base_url)
            return results
        except Exception as e:
            self.logger.error(f"Error running Gobuster scan: {e}")
            results["error"] = str(e)
            return results

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(levelname)s: %(message)s')
    
    # --- Test Dirb ---
    print("\n--- Testing DirbRunner ---")
    dirb_scanner = DirbRunner()
    if dirb_scanner.available:
        # test_url_dirb = "http://testphp.vulnweb.com/"
        test_url_dirb = "http://localhost/" # Test against a local web server
        print(f"Scanning with Dirb: {test_url_dirb}")
        # dirb_results = dirb_scanner.scan(test_url_dirb, extensions=[".php", ".txt"], recursive=False) # recursive=False -> non-recursive
        dirb_results = dirb_scanner.scan(test_url_dirb, extensions=[".php"])


        if dirb_results.get("error"):
            print(f"  Dirb Error: {dirb_results['error']}")
        if dirb_results.get("found_paths"):
            print("  Dirb Found Paths (first 5):")
            for item in dirb_results["found_paths"][:5]:
                print(f"    - URL: {item['url']}, Status: {item.get('status_code', 'N/A')}, Type: {item.get('type')}")
        else:
            print("  No paths found by Dirb or error in scan.")
        print(f"  Dirb command: {dirb_results.get('command_used')}")
        # print(json.dumps(dirb_results, indent=2))
    else:
        print("Dirb scanner not available.")

    # --- Test Gobuster ---
    print("\n--- Testing GobusterRunner ---")
    gobuster_scanner = GobusterRunner()
    if gobuster_scanner.available:
        # test_url_gobuster = "http://testphp.vulnweb.com"
        test_url_gobuster = "http://localhost" # Test against a local web server
        print(f"Scanning with Gobuster: {test_url_gobuster}")
        # gobuster_results = gobuster_scanner.scan(test_url_gobuster, extensions=["php", "txt"], quiet=True)
        gobuster_results = gobuster_scanner.scan(test_url_gobuster, extensions=["php"])


        if gobuster_results.get("error"):
            print(f"  Gobuster Error: {gobuster_results['error']}")
        if gobuster_results.get("found_paths"):
            print("  Gobuster Found Paths (first 5):")
            for item in gobuster_results["found_paths"][:5]:
                print(f"    - URL: {item['url']}, Status: {item.get('status_code', 'N/A')}")
        else:
            print("  No paths found by Gobuster or error in scan.")
        print(f"  Gobuster command: {gobuster_results.get('command_used')}")
        # print(json.dumps(gobuster_results, indent=2))
    else:
        print("Gobuster scanner not available.")