#!/usr/bin/env python3
"""
Wrappers for Dirb and Gobuster directory/file brute-forcing tools.
"""

import subprocess
import os
import logging
from typing import List, Dict, Any, Optional, Tuple
import re

class DirbRunner:
    """Wrapper for the Dirb directory/file scanner."""

    def __init__(self, dirb_path: str = "dirb", logger: Optional[logging.Logger] = None):
        """
        Initialize the Dirb runner.

        Args:
            dirb_path: Path to the dirb executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("dirb_runner")
        self.dirb_path = dirb_path
        self.default_wordlist = "/usr/share/dirb/wordlists/common.txt" # Common default on Kali
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if Dirb is installed."""
        try:
            # Dirb doesn't have a simple --version. It prints help if no args.
            result = subprocess.run([self.dirb_path], capture_output=True, text=True, timeout=5)
            if "DIRB" in result.stdout and "דירב" in result.stdout: # Checks for ASCII art and Hebrew name
                self.logger.info(f"Dirb found at {self.dirb_path}")
                return True
            else:
                self.logger.warning(f"Dirb not behaving as expected at {self.dirb_path}. Output: {result.stdout[:200]}")
                return False
        except FileNotFoundError:
            self.logger.error(f"Dirb executable not found at {self.dirb_path}. Please install Dirb.")
            return False
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout checking Dirb availability at {self.dirb_path}.")
            return False
        except Exception as e:
            self.logger.error(f"Error checking Dirb availability: {e}")
            return False

    def _parse_dirb_output(self, output_text: str, base_url: str) -> List[Dict[str, Any]]:
        """
        Parse Dirb's text output.
        Example lines:
        + http://example.com/found_dir/ (CODE:200|SIZE:1234)
        ==> DIRECTORY: http://example.com/another_dir/
        """
        found_items = []
        # Ensure base_url ends with a slash if it's likely a directory context for joining
        if not base_url.endswith('/') and '.' not in base_url.split('/')[-1]:
            base_url += '/'

        for line in output_text.splitlines():
            line = line.strip()
            if line.startswith("+ ") or line.startswith("==> DIRECTORY:"):
                path = ""
                code = None
                size = None
                is_directory = line.startswith("==> DIRECTORY:")

                if is_directory:
                    match = re.search(r"DIRECTORY:\s*(.*)", line)
                    if match:
                        path = match.group(1).strip()
                else: # Starts with "+ "
                    match = re.search(r"\+\s*(.*?)\s*\(CODE:(\d+)\|SIZE:(\S+)\)", line)
                    if match:
                        path = match.group(1).strip()
                        code = int(match.group(2))
                        size_str = match.group(3)
                        try:
                            size = int(size_str) if size_str.isdigit() else None
                        except ValueError:
                            size = None # Or keep as string if needed
                
                if path:
                    # Ensure full URL. Dirb sometimes gives full, sometimes relative.
                    full_url = path if path.startswith("http") else (base_url.rstrip('/') + '/' + path.lstrip('/'))
                    # A simple way to normalize multiple slashes, though urljoin is more robust
                    full_url = full_url.replace('//', '/').replace(':/', '://')


                    found_items.append({
                        "url": full_url,
                        "status_code": code,
                        "size": size,
                        "type": "directory" if is_directory or (code and full_url.endswith('/')) else "file"
                    })
        return found_items

    def scan(self, base_url: str, wordlist: Optional[str] = None,
             extensions: Optional[List[str]] = None, # e.g., [".php", ".html"]
             recursive: bool = False,
             additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run Dirb against a base URL.

        Args:
            base_url: The base URL to scan (e.g., "http://example.com/").
            wordlist: Path to the wordlist file. Uses default if None.
            extensions: List of extensions to test (e.g., [".txt", ".php"]). Dirb uses -X.
            recursive: Perform recursive scan (-r).
            additional_args: List of additional Dirb arguments.

        Returns:
            Dict containing scan results.
        """
        if not self.available:
            return {"error": "Dirb scanner not available."}

        final_wordlist = wordlist or self.default_wordlist
        if not os.path.exists(final_wordlist):
            self.logger.error(f"Dirb wordlist not found: {final_wordlist}")
            return {"error": f"Dirb wordlist not found: {final_wordlist}"}

        results: Dict[str, Any] = {
            "base_url_scanned": base_url,
            "wordlist_used": final_wordlist,
            "found_paths": [],
            "error": None,
            "command_used": ""
        }

        cmd = [self.dirb_path, base_url, final_wordlist]

        if extensions:
            for ext in extensions:
                cmd.extend(["-X", ext if ext.startswith('.') else "." + ext])
        
        if not recursive: # Dirb is recursive by default. -r makes it non-recursive on found dirs.
                          # This is confusing. If user wants to scan deeper, they usually mean deeper.
                          # Dirb's -R option is for "Recurse into found directories from initial scan"
                          # The common understanding of "recursive" for dirbusters is to go deeper.
                          # Dirb's default behavior IS recursive.
                          # Let's assume `recursive=True` means the default behavior, and `recursive=False` means use `-r` for non-recursive.
            pass # Default is recursive
        else: # if recursive is set to True by user, it means they want to ensure it.
              # if set to False, use -r (non-recursive after initial find)
            # This logic is a bit tricky due to Dirb's -r flag meaning "Do not recurse into found subdirectories".
            # Most users expect "recursive=True" to mean "go deep". Dirb does this by default.
            # If recursive=False, then add -r to limit recursion.
            # The variable name `recursive` might be misleading here.
            # Let's assume user wants non-recursive only if they explicitly set `recursive=False`.
            # The parameter `recursive: bool = False` means by default it *is* recursive.
            # If they pass `recursive=True` it means they want the default.
            # If they pass `recursive=False` it means they want `-r`.
            # To make it clearer: if `recursive` (parameter) is True, do nothing (default Dirb).
            # If `recursive` (parameter) is False, add `-r` to Dirb.
            # The current default `recursive: bool = False` means if user doesn't specify, it will add `-r`.
            # This is opposite of what's intuitive. Let's adjust:
            # `recursive: bool = True` means it IS recursive by default.
            # If user passes `recursive=False`, then we add `-r`.
            if not recursive: # If `recursive` parameter is False
                 cmd.append("-r") # Add Dirb's non-recursive flag
        
        if additional_args:
            cmd.extend(additional_args)
        
        results["command_used"] = " ".join(cmd)
        self.logger.info(f"Running Dirb command: {results['command_used']}")

        try:
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, errors='replace')
            stdout, stderr = process.communicate(timeout=1800) # 30-minute timeout

            if stderr:
                self.logger.warning(f"Dirb stderr: {stderr.strip()}")
                if "FATAL" in stderr.upper() or "ERROR" in stderr.upper(): # Dirb errors often go to stderr
                    results["error"] = stderr.strip()

            if process.returncode != 0 and not results["error"]:
                results["error"] = f"Dirb process exited with code {process.returncode}. Stderr: {stderr.strip()}"
            
            if stdout:
                results["found_paths"] = self._parse_dirb_output(stdout, base_url)
            
            return results

        except subprocess.TimeoutExpired:
            self.logger.error(f"Dirb scan timed out for base_url: {base_url}")
            results["error"] = "Dirb scan timed out."
            # Try to parse any stdout obtained before timeout
            if 'stdout' in locals() and stdout:
                 results["found_paths"] = self._parse_dirb_output(stdout, base_url)
            return results
        except Exception as e:
            self.logger.error(f"Error running Dirb scan: {e}")
            results["error"] = str(e)
            return results

class GobusterRunner:
    """Wrapper for the Gobuster tool (specifically 'dir' mode)."""

    def __init__(self, gobuster_path: str = "gobuster", logger: Optional[logging.Logger] = None):
        """
        Initialize the Gobuster runner.

        Args:
            gobuster_path: Path to the gobuster executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("gobuster_runner")
        self.gobuster_path = gobuster_path
        self.default_wordlist = "/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt" # Common default
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if Gobuster is installed."""
        try:
            result = subprocess.run([self.gobuster_path, "version"], capture_output=True, text=True, timeout=5)
            if result.returncode == 0 and "Gobuster" in result.stdout:
                self.logger.info(f"Gobuster found: {result.stdout.strip()}")
                return True
            else:
                self.logger.warning(f"Gobuster not behaving as expected at {self.gobuster_path}. Output: {result.stdout} {result.stderr}")
                return False
        except FileNotFoundError:
            self.logger.error(f"Gobuster executable not found at {self.gobuster_path}. Please install Gobuster.")
            return False
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout checking Gobuster availability at {self.gobuster_path}.")
            return False
        except Exception as e:
            self.logger.error(f"Error checking Gobuster availability: {e}")
            return False

    def _parse_gobuster_output(self, output_text: str, base_url: str) -> List[Dict[str, Any]]:
        """
        Parse Gobuster's text output for 'dir' mode.
        Example lines (without -q):
        Found: /path/to/file (Status: 200)
        Found: /another_dir/ (Status: 301)
        If -q is used, it's just the path:
        /path/to/file
        /another_dir/
        This parser will try to handle both, but prefers non-quiet for status codes.
        """
        found_items = []
        # Ensure base_url ends with a slash for proper joining
        if not base_url.endswith('/'):
            base_url += '/'

        for line in output_text.splitlines():
            line = line.strip()
            if not line or line.startswith("#") or line.startswith("Progress:") or "===" in line:
                continue # Skip comments, progress, or header lines

            path = None
            status_code = None
            
            # Try to match lines with status code first (e.g., "Found: /admin (Status: 200)")
            # Gobuster's output format can vary slightly with versions.
            # Common format: "Found: /path (Status: XXX)" or "/path (Status: XXX)"
            # Or just "/path" if quiet mode.
            match_with_status = re.match(r"(?:Found:\s*)?(.+?)\s*\(Status:\s*(\d+)\)", line, re.IGNORECASE)
            if match_with_status:
                path = match_with_status.group(1).strip()
                status_code = int(match_with_status.group(2))
            else: # Assume quiet mode or a simpler format, path only
                path = line # The whole line is the path

            if path:
                # Gobuster paths are usually relative to the base URL
                full_url = base_url.rstrip('/') + path if path.startswith('/') else base_url + path
                # Normalize multiple slashes
                full_url = full_url.replace('//', '/').replace(':/', '://')


                found_items.append({
                    "url": full_url,
                    "status_code": status_code, # Will be None if quiet mode was used and not extractable
                    "type": "directory" if full_url.endswith('/') else "file"
                })
        return found_items

    def scan(self, base_url: str, wordlist: Optional[str] = None,
             extensions: Optional[List[str]] = None, # e.g., ["php", "html"] (no dot for gobuster)
             status_codes: Optional[str] = "200,204,301,302,307,401,403", # Default good codes
             threads: int = 10,
             quiet: bool = False, # -q for less verbose output
             additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run Gobuster 'dir' mode scan.

        Args:
            base_url: The base URL to scan (e.g., "http://example.com").
            wordlist: Path to the wordlist file. Uses default if None.
            extensions: Comma-separated list of extensions (e.g., "php,html,txt").
            status_codes: Comma-separated status codes to show (e.g., "200,301,403").
            threads: Number of concurrent threads.
            quiet: Suppress banner and other noise.
            additional_args: List of additional Gobuster arguments.

        Returns:
            Dict containing scan results.
        """
        if not self.available:
            return {"error": "Gobuster scanner not available."}

        final_wordlist = wordlist or self.default_wordlist
        if not os.path.exists(final_wordlist):
            self.logger.error(f"Gobuster wordlist not found: {final_wordlist}")
            return {"error": f"Gobuster wordlist not found: {final_wordlist}"}

        results: Dict[str, Any] = {
            "base_url_scanned": base_url,
            "wordlist_used": final_wordlist,
            "found_paths": [],
            "error": None,
            "command_used": ""
        }

        cmd = [self.gobuster_path, "dir", "-u", base_url, "-w", final_wordlist]
        cmd.extend(["-t", str(threads)])

        if extensions:
            # Gobuster expects extensions without a dot, comma-separated: -x php,html
            ext_string = ",".join([e.lstrip('.') for e in extensions])
            cmd.extend(["-x", ext_string])
        
        if status_codes:
            cmd.extend(["-s", status_codes])
        
        if quiet:
            cmd.append("-q")
        else: # If not quiet, good to have --no-progress for cleaner logs in automation
            cmd.append("--no-progress")


        if additional_args:
            cmd.extend(additional_args)
        
        results["command_used"] = " ".join(cmd)
        self.logger.info(f"Running Gobuster command: {results['command_used']}")

        try:
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, errors='replace')
            stdout, stderr = process.communicate(timeout=1800) # 30-minute timeout

            if stderr:
                self.logger.warning(f"Gobuster stderr: {stderr.strip()}")
                if "error" in stderr.lower() or "panic" in stderr.lower():
                    results["error"] = stderr.strip()
            
            if process.returncode != 0 and not results["error"]:
                results["error"] = f"Gobuster process exited with code {process.returncode}. Stderr: {stderr.strip()}"
            
            if stdout:
                results["found_paths"] = self._parse_gobuster_output(stdout, base_url)
            
            return results

        except subprocess.TimeoutExpired:
            self.logger.error(f"Gobuster scan timed out for base_url: {base_url}")
            results["error"] = "Gobuster scan timed out."
            if 'stdout' in locals() and stdout: # Check if stdout was captured before timeout
                 results["found_paths"] = self._parse_gobuster_output(stdout, base_url)
            return results
        except Exception as e:
            self.logger.error(f"Error running Gobuster scan: {e}")
            results["error"] = str(e)
            return results

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(levelname)s: %(message)s')
    
    # --- Test Dirb ---
    print("\n--- Testing DirbRunner ---")
    dirb_scanner = DirbRunner()
    if dirb_scanner.available:
        # test_url_dirb = "http://testphp.vulnweb.com/"
        test_url_dirb = "http://localhost/" # Test against a local web server
        print(f"Scanning with Dirb: {test_url_dirb}")
        # dirb_results = dirb_scanner.scan(test_url_dirb, extensions=[".php", ".txt"], recursive=False) # recursive=False -> non-recursive
        dirb_results = dirb_scanner.scan(test_url_dirb, extensions=[".php"])


        if dirb_results.get("error"):
            print(f"  Dirb Error: {dirb_results['error']}")
        if dirb_results.get("found_paths"):
            print("  Dirb Found Paths (first 5):")
            for item in dirb_results["found_paths"][:5]:
                print(f"    - URL: {item['url']}, Status: {item.get('status_code', 'N/A')}, Type: {item.get('type')}")
        else:
            print("  No paths found by Dirb or error in scan.")
        print(f"  Dirb command: {dirb_results.get('command_used')}")
        # print(json.dumps(dirb_results, indent=2))
    else:
        print("Dirb scanner not available.")

    # --- Test Gobuster ---
    print("\n--- Testing GobusterRunner ---")
    gobuster_scanner = GobusterRunner()
    if gobuster_scanner.available:
        # test_url_gobuster = "http://testphp.vulnweb.com"
        test_url_gobuster = "http://localhost" # Test against a local web server
        print(f"Scanning with Gobuster: {test_url_gobuster}")
        # gobuster_results = gobuster_scanner.scan(test_url_gobuster, extensions=["php", "txt"], quiet=True)
        gobuster_results = gobuster_scanner.scan(test_url_gobuster, extensions=["php"])


        if gobuster_results.get("error"):
            print(f"  Gobuster Error: {gobuster_results['error']}")
        if gobuster_results.get("found_paths"):
            print("  Gobuster Found Paths (first 5):")
            for item in gobuster_results["found_paths"][:5]:
                print(f"    - URL: {item['url']}, Status: {item.get('status_code', 'N/A')}")
        else:
            print("  No paths found by Gobuster or error in scan.")
        print(f"  Gobuster command: {gobuster_results.get('command_used')}")
        # print(json.dumps(gobuster_results, indent=2))
    else:
        print("Gobuster scanner not available.")