#!/usr/bin/env python3
"""
Wrapper for OWASP ZAP (Zed Attack Proxy) scanner.
"""

import time
import logging
import os
from typing import Dict, Any, List, Optional
from zapv2 import ZAPv2

class ZAPScanner:
    """
    Wrapper for OWASP ZAP to perform web application vulnerability scanning.
    """
    def __init__(self, zap_address: str = 'http://127.0.0.1', zap_port: int = 8080, 
                 api_key: str = None, logger: Optional[logging.Logger] = None):
        """
        Initialize the ZAPScanner.

        Args:
            zap_address: Address where ZAP is running.
            zap_port: Port ZAP is listening on.
            api_key: ZAP API key (required for most actions).
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("zap_scanner")
        self.api_key = api_key or os.getenv('ZAP_API_KEY') # Get API key from env if not provided
        self.zap_address = zap_address
        self.zap_port = zap_port
        
        if not self.api_key or self.api_key == "genius-penetration-zap-key":
            self.logger.warning("ZAP API key not provided or found in ZAP_API_KEY. ZAP scanner may not function correctly.")
            self.logger.info("A default API key 'genius-penetration-zap-key' will be used if ZAP is running with this key.")
            # Some ZAP instances might be configured to run without an API key for open access,
            # but this is not recommended for production/sensitive environments.

        # Set proxies with the correct format
        host = zap_address.replace('http://', '').replace('https://', '')
        proxies = {
            'http': f'{zap_address}:{zap_port}',
            'https': f'{zap_address}:{zap_port}'
        }
        
        try:
            self.zap = ZAPv2(apikey=self.api_key, proxies=proxies)
            self.available = self._check_availability()
        except Exception as e:
            self.logger.error(f"Error initializing ZAP client: {e}")
            self.available = False

    def _check_availability(self) -> bool:
        """Check if ZAP API is reachable."""
        try:
            version = self.zap.core.version
            self.logger.info(f"Connected to OWASP ZAP version: {version}")
            return True
        except Exception as e:
            self.logger.error(f"Error connecting to ZAP API: {e}. Ensure ZAP is running at the specified address/port and API key is correct.")
            return False

    def scan(self, target_url: str, scan_policy_name: str = None, 
             max_spider_duration: int = 5, max_scan_duration: int = 30) -> Dict[str, Any]:
        """
        Run a ZAP scan on the specified target URL.

        Args:
            target_url: The URL to scan (e.g., "http://example.com").
            scan_policy_name: Name of the scan policy to use (None for default).
            max_spider_duration: Maximum duration for spidering in minutes.
            max_scan_duration: Maximum duration for active scanning in minutes.

        Returns:
            Dict containing scan results.
        """
        if not self.available:
            return {"error": "ZAP scanner not available or not configured."}
        if not target_url.startswith(('http://', 'https://')):
            return {"error": "Invalid target URL. Must start with http:// or https://."}

        self.logger.info(f"Starting ZAP scan for target: {target_url}")
        results: Dict[str, Any] = {
            "target": target_url,
            "spider_status": "Not run",
            "active_scan_status": "Not run",
            "alerts": [],
            "vulnerability_count": 0
        }

        try:
            # 1. Access the target URL (optional, but good for session handling)
            self.zap.urlopen(target_url)
            time.sleep(2)

            # 2. Spider the target
            self.logger.info(f"Starting Spider for {target_url}")
            spider_scan_id = self.zap.spider.scan(target_url, recurse=True)
            time.sleep(2) # Give spider a moment to start

            start_time = time.time()
            while (int(self.zap.spider.status(spider_scan_id)) < 100):
                if (time.time() - start_time) / 60 > max_spider_duration:
                    self.logger.warning(f"Spider timed out after {max_spider_duration} minutes for {target_url}")
                    self.zap.spider.stop(spider_scan_id)
                    break
                self.logger.debug(f"Spider progress for {target_url}: {self.zap.spider.status(spider_scan_id)}%")
                time.sleep(5)
            
            results["spider_status"] = f"Completed: {self.zap.spider.status(spider_scan_id)}%"
            self.logger.info(f"Spider finished for {target_url}. Progress: {self.zap.spider.status(spider_scan_id)}%")

            # 3. Active Scan
            self.logger.info(f"Starting Active Scan for {target_url}")
            active_scan_id = self.zap.ascan.scan(target_url, recurse=True, scanpolicyname=scan_policy_name)
            time.sleep(5) # Give active scan a moment to start

            start_time = time.time()
            while (int(self.zap.ascan.status(active_scan_id)) < 100):
                if (time.time() - start_time) / 60 > max_scan_duration:
                    self.logger.warning(f"Active Scan timed out after {max_scan_duration} minutes for {target_url}")
                    self.zap.ascan.stop(active_scan_id)
                    break
                self.logger.debug(f"Active Scan progress for {target_url}: {self.zap.ascan.status(active_scan_id)}%")
                time.sleep(10)
            
            results["active_scan_status"] = f"Completed: {self.zap.ascan.status(active_scan_id)}%"
            self.logger.info(f"Active Scan finished for {target_url}. Progress: {self.zap.ascan.status(active_scan_id)}%")

            # 4. Retrieve Alerts
            alerts = self.zap.core.alerts(baseurl=target_url)
            processed_alerts = []
            for alert in alerts:
                processed_alerts.append({
                    "name": alert.get("name"),
                    "risk": alert.get("risk"),
                    "confidence": alert.get("confidence"),
                    "description": alert.get("description"),
                    "url": alert.get("url"),
                    "param": alert.get("param"),
                    "evidence": alert.get("evidence"),
                    "solution": alert.get("solution"),
                    "cweid": alert.get("cweid"),
                    "wascid": alert.get("wascid"),
                    "pluginId": alert.get("pluginId")
                })
            results["alerts"] = processed_alerts
            results["vulnerability_count"] = len(processed_alerts)

            # Optionally, generate a report
            # report_name = f"ZAP_Report_{target_url.replace('http://','').replace('https://','').replace('/','_')}.html"
            # report_path = os.path.join(os.getcwd(), report_name) # Adjust path as needed
            # self.zap.core.htmlreport(apikey=self.api_key, reportfilename=report_path)
            # self.logger.info(f"ZAP HTML report generated at {report_path}")
            # results["report_path"] = report_path


        except Exception as e:
            self.logger.error(f"Error during ZAP scan for {target_url}: {e}")
            results["error"] = str(e)
        
        self.logger.info(f"ZAP scan for {target_url} completed. Found {results['vulnerability_count']} alerts.")
        return results

if __name__ == '__main__':
    # Example Usage (Ensure ZAP is running with API enabled)
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(levelname)s: %(message)s')
    
    # Set ZAP_API_KEY environment variable or pass it directly
    # zap_api_key = "YOUR_ZAP_API_KEY" 
    zap_api_key = os.getenv('ZAP_API_KEY')

    if not zap_api_key:
        print("Please set the ZAP_API_KEY environment variable or provide it in the script.")
    else:
        scanner = ZAPScanner(api_key=zap_api_key)
        if scanner.available:
            # test_target = "http://testphp.vulnweb.com" # A deliberately vulnerable site for testing
            test_target = "https://public-firing-range.appspot.com" # Google Firing Range
            
            print(f"Scanning target: {test_target}")
            scan_results = scanner.scan(test_target, max_spider_duration=1, max_scan_duration=5) # Short durations for testing
            
            print("\nScan Results:")
            if "error" in scan_results:
                print(f"Error: {scan_results['error']}")
            else:
                print(f"  Target: {scan_results['target']}")
                print(f"  Spider Status: {scan_results['spider_status']}")
                print(f"  Active Scan Status: {scan_results['active_scan_status']}")
                print(f"  Vulnerabilities Found: {scan_results['vulnerability_count']}")
                
                if scan_results['vulnerability_count'] > 0:
                    print("\n  Alerts Summary:")
                    for alert in scan_results['alerts'][:5]: # Print first 5 alerts
                        print(f"    - Name: {alert['name']}, Risk: {alert['risk']}, URL: {alert['url']}")
                    if scan_results['vulnerability_count'] > 5:
                        print(f"    ... and {scan_results['vulnerability_count'] - 5} more alerts.")
            
            # To get full JSON output:
            # import json
            # print(json.dumps(scan_results, indent=2))
        else:
            print("ZAP Scanner is not available. Check connection and configuration.")