#!/usr/bin/env python3
"""
Wrapper for the XSSer (Cross-Site Scripter) framework.
"""

import subprocess
import os
import logging
from typing import List, Dict, Any, Optional
import tempfile
import xml.etree.ElementTree as ET # For parsing XML reports

class XSSerScanner:
    """Wrapper for the XSSer framework."""
    
    def __init__(self, xsser_path: str = "xsser", logger: Optional[logging.Logger] = None):
        """
        Initialize the XSSer scanner wrapper.

        Args:
            xsser_path: Path to the xsser executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("xsser_scanner")
        self.xsser_path = xsser_path
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if XSSer is installed and executable."""
        try:
            # XSSer often returns non-zero exit code even for --version if certain deps are missing,
            # but it will print version info.
            result = subprocess.run([self.xsser_path, "--version"], 
                                   capture_output=True, # Use capture_output for stdout/stderr
                                   text=True, timeout=10) # Added timeout
            # XSSer version info might be in stdout or stderr
            version_info = result.stdout + result.stderr
            if "XSSer" in version_info and ("version" in version_info.lower() or "codenamed" in version_info.lower()):
                # Try to extract a version string more cleanly
                first_line_stdout = result.stdout.strip().splitlines()[0] if result.stdout.strip() else ""
                first_line_stderr = result.stderr.strip().splitlines()[0] if result.stderr.strip() else ""
                self.logger.info(f"XSSer found. stdout: {first_line_stdout}, stderr: {first_line_stderr}")
                return True
            else:
                self.logger.warning(f"XSSer not behaving as expected at {self.xsser_path}. Output: {version_info}")
                return False
        except FileNotFoundError:
            self.logger.error(f"XSSer executable not found at {self.xsser_path}. Please install XSSer (e.g., 'sudo apt install xsser') or provide the correct path.")
            return False
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout checking XSSer availability at {self.xsser_path}.")
            return False
        except Exception as e:
            self.logger.error(f"Error checking XSSer availability: {e}")
            return False

    def _parse_xsser_xml_report(self, xml_file_path: str) -> List[Dict[str, Any]]:
        """
        Parse XSSer XML report file.
        XSSer XML structure (simplified):
        <xsser_report>
            <target url="...">
                <vulnerability type="..." method="...">
                    <payload>...</payload>
                    <result_url>...</result_url>
                    ...
                </vulnerability>
            </target>
        </xsser_report>
        """
        vulnerabilities = []
        try:
            tree = ET.parse(xml_file_path)
            root = tree.getroot()
            
            for target_node in root.findall('.//target'):
                target_url = target_node.get('url')
                for vuln_node in target_node.findall('.//vulnerability'):
                    vuln_details = {
                        "target_url": target_url,
                        "type": vuln_node.get('type'),
                        "method": vuln_node.get('method'), # GET or POST
                        "payload": vuln_node.findtext('payload', default='').strip(),
                        "result_url": vuln_node.findtext('result_url', default='').strip(),
                        "parameter": vuln_node.findtext('parameter', default='').strip(), # If available
                        "description": f"XSS vulnerability of type '{vuln_node.get('type')}' found in parameter '{vuln_node.findtext('parameter', default='N/A')}' using method '{vuln_node.get('method')}'."
                    }
                    vulnerabilities.append(vuln_details)
        except ET.ParseError as e:
            self.logger.error(f"Error parsing XSSer XML report {xml_file_path}: {e}")
        except Exception as e:
            self.logger.error(f"Unexpected error parsing XSSer XML report {xml_file_path}: {e}")
        return vulnerabilities

    def scan(self, target_url: str, 
             params_to_test: Optional[List[str]] = None, # e.g., ["q=test", "id=1"] for GET, or data for POST
             method: str = "GET", # "GET" or "POST"
             use_heuristic: bool = True,
             additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run an XSSer scan on the specified target URL.
        
        Args:
            target_url: The URL to scan (e.g., "http://example.com/search.php").
            params_to_test: List of parameters and example values (e.g., "q=XSS", "name=test").
                            For GET, these are appended to URL. For POST, this is the data.
            method: HTTP method ("GET" or "POST").
            use_heuristic: Use XSSer's heuristic engine (--heuristic).
            additional_args: List of additional arguments to pass to XSSer.
            
        Returns:
            Dict containing scan results.
        """
        if not self.available:
            return {"error": "XSSer scanner not available."}
        
        results: Dict[str, Any] = {
            "target_url": target_url,
            "method": method,
            "vulnerabilities": [],
            "command": "",
            "error": None
        }

        report_file = None
        try:
            # Create a temporary XML report file
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".xml") as tmp_report:
                report_file = tmp_report.name
            
            cmd = [self.xsser_path, "-u", target_url, "--xml", report_file]

            if method.upper() == "GET" and params_to_test:
                # For GET, XSSer usually infers parameters from the URL or uses -g
                # If target_url doesn't have params, and params_to_test is given, construct GET query
                # XSSer is a bit particular. It might be better to use -g for specific GET params.
                # Or ensure target_url already contains query parameters if testing GET.
                # For this wrapper, if params_to_test are provided for GET, we'll use -g for each.
                # Example: xsser -u "http://host/path" -g "param1=val1" -g "param2=val2"
                for p_val in params_to_test:
                    cmd.extend(["-g", p_val])
            elif method.upper() == "POST" and params_to_test:
                # For POST, use -p and join params_to_test with '&'
                post_data = "&".join(params_to_test)
                cmd.extend(["-p", post_data])
            
            if use_heuristic:
                cmd.append("--heuristic") # More checks, potentially more FPs
            
            # Common useful options you might want to add via additional_args or expose as params:
            # --Cw=10 (crawl depth)
            # --De=<encoder> (e.g., --De=Base64)
            # --D=<payload_file> (custom payloads)
            # --threads=<num>
            # --timeout=<sec>
            # --auto (auto-detect and inject in all vulnerable parameters) - can be noisy
            
            if additional_args:
                cmd.extend(additional_args)
            
            results["command"] = " ".join(cmd)
            self.logger.info(f"Running XSSer command: {results['command']}")
            
            # XSSer can take a long time. Timeout is important.
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            # XSSer can run for a very long time, adjust timeout as needed.
            # A short timeout for general testing, longer for thorough scans.
            stdout, stderr = process.communicate(timeout=1800) # 30-minute timeout

            self.logger.debug(f"XSSer stdout: {stdout}")
            if stderr:
                 self.logger.info(f"XSSer stderr: {stderr.strip()}")
                 # XSSer often prints non-error info to stderr.
                 # Filter for actual errors if possible, or just log it.

            if process.returncode != 0:
                 # XSSer might return non-zero even on successful detection.
                 # Focus on parsing the report.
                 self.logger.warning(f"XSSer process exited with code {process.returncode}. Stderr: {stderr.strip()}")

            # Parse the XML report
            if os.path.exists(report_file) and os.path.getsize(report_file) > 0:
                results["vulnerabilities"] = self._parse_xsser_xml_report(report_file)
            else:
                self.logger.warning(f"XSSer XML report file {report_file} not found or empty.")
                if not results["vulnerabilities"] and not results["error"]: # If no vulns and no prior error
                    results["error"] = "XSSer did not produce a report or the report was empty."
                    if stderr: results["error"] += f" Stderr: {stderr.strip()}"

            return results
            
        except subprocess.TimeoutExpired:
            self.logger.error(f"XSSer scan timed out for {target_url}.")
            results["error"] = "XSSer scan timed out."
            # Try to parse any partial report if it exists
            if report_file and os.path.exists(report_file) and os.path.getsize(report_file) > 0:
                 results["vulnerabilities"] = self._parse_xsser_xml_report(report_file)
                 if results["vulnerabilities"]:
                     results["error"] += " Partial results might be available."
            return results
        except Exception as e:
            self.logger.error(f"Error running XSSer scan for {target_url}: {e}")
            results["error"] = str(e)
            return results
        finally:
            if report_file and os.path.exists(report_file):
                try:
                    os.unlink(report_file)
                except Exception as e_unlink:
                    self.logger.warning(f"Could not delete temporary XSSer report file {report_file}: {e_unlink}")


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(levelname)s: %(message)s')
    
    scanner = XSSerScanner()

    if scanner.available:
        # Test with a known vulnerable site or a local test setup.
        # Using Google Firing Range XSS examples.
        # Note: XSSer can be slow.
        
        # Example 1: GET based XSS
        # test_url_get = "https://public-firing-range.appspot.com/html/BODY/attributes/onkeyup.html?query=test"
        # params_get = ["query=attacker_controlled"] # XSSer will try to inject into 'query'

        # Simpler test from XSSer's documentation (if dvwa is setup)
        # test_url_get = "http://dvwa.local/vulnerabilities/xss_r/?name=" 
        # params_get = None # XSSer will try to inject into 'name' if --auto or specific payloads are used.
                           # Or specify params like ["name=XSS"] and it will try variations.

        # Let's use a very simple, controllable local endpoint if possible for reliable testing.
        # For now, we'll use a public test site, but results can vary.
        
        # Test case from OWASP Broken Web Applications Project (if you have it running)
        # test_url_get = "http://192.168.X.X/bwapp/xss_get.php"
        # params_get = ["firstname=test", "lastname=test"]

        # Using a public test site that is often used for XSS demos
        test_url_get = "http://testphp.vulnweb.com/search.php"
        params_get = ["searchFor=test_query"] # Test the 'searchFor' parameter

        print(f"Scanning GET URL: {test_url_get} with params: {params_get}")
        # For --auto, it tries to find injectable parameters itself. Might be better for generic wrapper.
        # scan_results_get = scanner.scan(test_url_get, params_to_test=params_get, method="GET", additional_args=["--auto", "--timeout=10", "--threads=3"])
        scan_results_get = scanner.scan(test_url_get, params_to_test=params_get, method="GET", additional_args=["--timeout=20", "--threads=2"])


        print("\nGET Scan Results:")
        if scan_results_get.get("error"):
            print(f"  Error: {scan_results_get['error']}")
        if scan_results_get["vulnerabilities"]:
            print("  Vulnerabilities Found:")
            for vuln in scan_results_get["vulnerabilities"]:
                print(f"    - Type: {vuln['type']}, Method: {vuln['method']}, Payload: {vuln['payload'][:50]}...") # Show first 50 chars of payload
        else:
            print("  No XSS vulnerabilities found by XSSer for GET parameters.")
        print(f"  XSSer command used: {scan_results_get['command']}")
        
        # import json
        # print("\nFull JSON Output (GET):")
        # print(json.dumps(scan_results_get, indent=2))

    else:
        print("XSSer scanner is not available. Please install XSSer or check the path.")