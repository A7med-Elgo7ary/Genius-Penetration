#!/usr/bin/env python3
"""
Wrapper for the XSSer (Cross-Site Scripter) framework.
"""

import subprocess
import os
import logging
from typing import List, Dict, Any, Optional
import tempfile
import xml.etree.ElementTree as ET # For parsing XML reports

class XSSerScanner:
    """Wrapper for the XSSer framework."""
    
    def __init__(self, xsser_path: str = "xsser", logger: Optional[logging.Logger] = None):
        """
        Initialize the XSSer scanner wrapper.

        Args:
            xsser_path: Path to the xsser executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("xsser_scanner")
        self.xsser_path = xsser_path
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if XSSer is installed and executable."""
        try:
            # Try a simpler check first
            result = subprocess.run([self.xsser_path], 
                                   capture_output=True,
                                   text=True, timeout=10)
            
            # XSSer might output to either stdout or stderr
            output = result.stdout + result.stderr
            
            # Check for known XSSer output patterns
            if "XSSer" in output and any(x in output for x in ["Cross Site", "Scripter", "usage", "OPTIONS"]):
                self.logger.info(f"XSSer found at {self.xsser_path}")
                return True
            
            # If the simple check didn't work, try with --help
            result = subprocess.run([self.xsser_path, "--help"], 
                                   capture_output=True,
                                   text=True, timeout=10)
                                   
            output = result.stdout + result.stderr
            if "XSSer" in output:
                self.logger.info(f"XSSer found with --help at {self.xsser_path}")
                return True
            else:
                self.logger.warning(f"XSSer not behaving as expected at {self.xsser_path}. Output: {output[:200]}")
                return False
                
        except FileNotFoundError:
            self.logger.error(f"XSSer executable not found at {self.xsser_path}. Please install XSSer (e.g., 'sudo apt install xsser') or provide the correct path.")
            return False
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout checking XSSer availability at {self.xsser_path}.")
            return False
        except Exception as e:
            self.logger.error(f"Error checking XSSer availability: {e}")
            return False

    def _parse_xsser_xml_report(self, xml_file_path: str) -> List[Dict[str, Any]]:
        """
        Parse XSSer XML report file.
        XSSer XML structure (simplified):
        <xsser_report>
            <target url="...">
                <vulnerability type="..." method="...">
                    <payload>...</payload>
                    <result_url>...</result_url>
                    ...
                </vulnerability>
            </target>
        </xsser_report>
        """
        vulnerabilities = []
        try:
            tree = ET.parse(xml_file_path)
            root = tree.getroot()
            
            for target_node in root.findall('.//target'):
                target_url = target_node.get('url')
                for vuln_node in target_node.findall('.//vulnerability'):
                    vuln_details = {
                        "target_url": target_url,
                        "type": vuln_node.get('type'),
                        "method": vuln_node.get('method'), # GET or POST
                        "payload": vuln_node.findtext('payload', default='').strip(),
                        "result_url": vuln_node.findtext('result_url', default='').strip(),
                        "parameter": vuln_node.findtext('parameter', default='').strip(), # If available
                        "description": f"XSS vulnerability of type '{vuln_node.get('type')}' found in parameter '{vuln_node.findtext('parameter', default='N/A')}' using method '{vuln_node.get('method')}'."
                    }
                    vulnerabilities.append(vuln_details)
        except ET.ParseError as e:
            self.logger.error(f"Error parsing XSSer XML report {xml_file_path}: {e}")
        except Exception as e:
            self.logger.error(f"Unexpected error parsing XSSer XML report {xml_file_path}: {e}")
        return vulnerabilities

    def scan(self, target_url: List[str] | str, 
         params_to_test: Optional[List[str]] = None, # e.g., ["q=test", "id=1"] for GET, or data for POST
         method: str = "GET", # "GET" or "POST"
         use_heuristic: bool = True,
         get: bool = False,
         auto: bool = False,
         commands: Optional[List[str]] = None,
         additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run an XSSer scan on the specified target URL.
        
        Args:
            target_url: The URL or list of URLs to scan (e.g., "http://example.com/search.php").
            params_to_test: List of parameters and example values (e.g., "q=XSS", "name=test").
                            For GET, these are appended to URL. For POST, this is the data.
            method: HTTP method ("GET" or "POST").
            use_heuristic: Use XSSer's heuristic engine (--heuristic).
            get: Use GET method explicitly (adds -g flag)
            auto: Use auto mode to automatically detect parameters (adds --auto flag)
            commands: Optional specific XSS payload commands to use
            additional_args: List of additional arguments to pass to XSSer.
            
        Returns:
            Dict containing scan results.
        """
        if not self.available:
            return {"error": "XSSer scanner not available."}
    
        # Initialize results structure with proper keys for vulnerability report format
        results: Dict[str, Any] = {
            "target_url": target_url,
            "method": method,
            "vulnerabilities": [],
            "command": "",
            "error": None,
            "summary": "XSSer scan results",
            "vulnerability_counts": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0
            },
            "raw_data": {"note": "Original scanner output stored internally"}
        }

        report_file = None
        try:
            # Create a temporary XML report file
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".xml") as tmp_report:
                report_file = tmp_report.name
        
            # Handle single URL or list of URLs
            if isinstance(target_url, list):
                if not target_url:  # Empty list
                    return {"error": "No target URLs provided"}
                # XSSer can take multiple -u parameters
                first_url = target_url[0]
                cmd = [self.xsser_path, "-u", first_url, "--xml", report_file]
                # Add additional URLs if provided
                for url in target_url[1:]:
                    cmd.extend(["-u", url])
            else:
                cmd = [self.xsser_path, "-u", target_url, "--xml", report_file]

            # Handle GET method parameters
            if method.upper() == "GET" and params_to_test:
                for p_val in params_to_test:
                    cmd.extend(["-g", p_val])
            # Handle POST method parameters
            elif method.upper() == "POST" and params_to_test:
                post_data = "&".join(params_to_test)
                cmd.extend(["-p", post_data])
        
            # Add the new supported parameters
            if get and not (method.upper() == "GET" and params_to_test):
                cmd.append("-g")
            
            if auto:
                cmd.append("--auto")
            
            if commands:
                for command in commands:
                    cmd.extend(["-c", command])
        
            if use_heuristic:
                cmd.append("--heuristic") # More checks, potentially more FPs
        
            # Add useful default settings if not overridden in additional_args
            if not any("--timeout" in arg for arg in (additional_args or [])):
                cmd.extend(["--timeout", "300"])  # 5 minute timeout by default
            
            if not any("--threads" in arg for arg in (additional_args or [])):
                cmd.extend(["--threads", "5"])  # 5 threads by default
            
            # Add any additional arguments
            if additional_args:
                cmd.extend(additional_args)
        
            results["command"] = " ".join(cmd)
            self.logger.info(f"Running XSSer command: {results['command']}")
            
            # XSSer can take a long time. Timeout is important.
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            # XSSer can run for a very long time, adjust timeout as needed.
            # A short timeout for general testing, longer for thorough scans.
            stdout, stderr = process.communicate(timeout=1800) # 30-minute timeout

            self.logger.debug(f"XSSer stdout: {stdout}")
            if stderr:
                 self.logger.info(f"XSSer stderr: {stderr.strip()}")
                 # XSSer often prints non-error info to stderr.
                 # Filter for actual errors if possible, or just log it.

            if process.returncode != 0:
                 # XSSer might return non-zero even on successful detection.
                 # Focus on parsing the report.
                 self.logger.warning(f"XSSer process exited with code {process.returncode}. Stderr: {stderr.strip()}")

            # Parse the XML report
            if os.path.exists(report_file) and os.path.getsize(report_file) > 0:
                results["vulnerabilities"] = self._parse_xsser_xml_report(report_file)
            else:
                self.logger.warning(f"XSSer XML report file {report_file} not found or empty.")
                if not results["vulnerabilities"] and not results["error"]: # If no vulns and no prior error
                    results["error"] = "XSSer did not produce a report or the report was empty."
                    if stderr: results["error"] += f" Stderr: {stderr.strip()}"

            return results
            
        except subprocess.TimeoutExpired:
            self.logger.error(f"XSSer scan timed out for {target_url}.")
            results["error"] = "XSSer scan timed out."
            # Try to parse any partial report if it exists
            if report_file and os.path.exists(report_file) and os.path.getsize(report_file) > 0:
                 results["vulnerabilities"] = self._parse_xsser_xml_report(report_file)
                 if results["vulnerabilities"]:
                     results["error"] += " Partial results might be available."
            return results
        except Exception as e:
            self.logger.error(f"Error running XSSer scan for {target_url}: {e}")
            results["error"] = str(e)
            return results
        finally:
            if report_file and os.path.exists(report_file):
                try:
                    os.unlink(report_file)
                except Exception as e_unlink:
                    self.logger.warning(f"Could not delete temporary XSSer report file {report_file}: {e_unlink}")


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(levelname)s: %(message)s')
    
    scanner = XSSerScanner()

    if scanner.available:
        # Test with a known vulnerable site or a local test setup.
        # Using Google Firing Range XSS examples.
        # Note: XSSer can be slow.
        
        # Example 1: GET based XSS
        # test_url_get = "https://public-firing-range.appspot.com/html/BODY/attributes/onkeyup.html?query=test"
        # params_get = ["query=attacker_controlled"] # XSSer will try to inject into 'query'

        # Simpler test from XSSer's documentation (if dvwa is setup)
        # test_url_get = "http://dvwa.local/vulnerabilities/xss_r/?name=" 
        # params_get = None # XSSer will try to inject into 'name' if --auto or specific payloads are used.
                           # Or specify params like ["name=XSS"] and it will try variations.

        # Let's use a very simple, controllable local endpoint if possible for reliable testing.
        # For now, we'll use a public test site, but results can vary.
        
        # Test case from OWASP Broken Web Applications Project (if you have it running)
        # test_url_get = "http://192.168.X.X/bwapp/xss_get.php"
        # params_get = ["firstname=test", "lastname=test"]

        # Using a public test site that is often used for XSS demos
        test_url_get = "http://testphp.vulnweb.com/search.php"
        params_get = ["searchFor=test_query"] # Test the 'searchFor' parameter

        print(f"Scanning GET URL: {test_url_get} with params: {params_get}")
        # For --auto, it tries to find injectable parameters itself. Might be better for generic wrapper.
        # scan_results_get = scanner.scan(test_url_get, params_to_test=params_get, method="GET", additional_args=["--auto", "--timeout=10", "--threads=3"])
        scan_results_get = scanner.scan(test_url_get, params_to_test=params_get, method="GET", additional_args=["--timeout=20", "--threads=2"])


        print("\nGET Scan Results:")
        if scan_results_get.get("error"):
            print(f"  Error: {scan_results_get['error']}")
        if scan_results_get["vulnerabilities"]:
            print("  Vulnerabilities Found:")
            for vuln in scan_results_get["vulnerabilities"]:
                print(f"    - Type: {vuln['type']}, Method: {vuln['method']}, Payload: {vuln['payload'][:50]}...") # Show first 50 chars of payload
        else:
            print("  No XSS vulnerabilities found by XSSer for GET parameters.")
        print(f"  XSSer command used: {scan_results_get['command']}")
        
        # import json
        # print("\nFull JSON Output (GET):")
        # print(json.dumps(scan_results_get, indent=2))

    else:
        print("XSSer scanner is not available. Please install XSSer or check the path.")