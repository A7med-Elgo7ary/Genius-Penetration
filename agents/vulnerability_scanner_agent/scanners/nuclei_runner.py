"""
Wrapper for the Nuclei scanner.
"""

import subprocess
import json
import os
import logging
from typing import List, Dict, Any, Optional
import tempfile

class NucleiScanner:
    """Wrapper for the Nuclei vulnerability scanner."""
    
    def __init__(self, nuclei_path: str = "nuclei", logger: Optional[logging.Logger] = None):
        """Initialize the Nuclei scanner wrapper."""
        self.logger = logger or logging.getLogger("nuclei_scanner")
        self.nuclei_path = nuclei_path
        
        # Direct check for Nuclei at known system path
        if os.path.exists("/usr/bin/nuclei"):
            self.nuclei_path = "/usr/bin/nuclei"
            self.logger.info(f"Using Nuclei from system path: {self.nuclei_path}")
        
        # Check if Nuclei is installed and functional
        try:
            # Try different version flags as Nuclei's CLI might vary
            for version_flag in ["-version", "--version", "-v"]:
                try:
                    result = subprocess.run([self.nuclei_path, version_flag], 
                                        stdout=subprocess.PIPE, 
                                        stderr=subprocess.PIPE,
                                        text=True,
                                        timeout=15)
                    combined_output = result.stdout + result.stderr
                    
                    # Look for any indication that it's Nuclei
                    if "nuclei" in combined_output.lower() or "projectdiscovery" in combined_output.lower():
                        self.logger.info(f"Nuclei found at {self.nuclei_path}")
                        self.available = True
                        return
                except subprocess.TimeoutExpired:
                    continue
                except Exception:
                    continue
            
            # Try running with no arguments
            result = subprocess.run([self.nuclei_path], 
                                stdout=subprocess.PIPE, 
                                stderr=subprocess.PIPE,
                                text=True,
                                timeout=5)
            combined_output = result.stdout + result.stderr
            
            if "nuclei" in combined_output.lower() or "usage" in combined_output.lower():
                self.logger.info(f"Nuclei detected with basic command at {self.nuclei_path}")
                self.available = True
                return
                
            # If we get here, Nuclei wasn't detected
            self.logger.warning(f"Nuclei not working correctly at {self.nuclei_path}")
            self.available = False
            
        except FileNotFoundError:
            self.logger.warning(f"Nuclei not found at {self.nuclei_path}. Please install Nuclei.")
            self.available = False
        except Exception as e:
            self.logger.warning(f"Error checking Nuclei availability: {str(e)}")
            self.available = False
    
    def scan(self, targets: List[str], templates: Optional[List[str]] = None, 
            severity: Optional[List[str]] = None, output_format: str = "json",
            rate_limit: int = 150, **kwargs) -> Dict[str, Any]:
        """
        Run a Nuclei scan on the specified targets.
        
        Args:
            targets: List of targets to scan (URLs, IP addresses, CIDR ranges)
            templates: Optional list of specific templates to use
            severity: Optional list of severity levels to scan for (critical, high, medium, low, info)
            output_format: Output format (json, sarif, etc.)
            rate_limit: Number of requests per second
            **kwargs: Additional parameters to pass to Nuclei
            
        Returns:
            Dict containing scan results
        """
        if not self.available:
            return {"error": "Nuclei scanner not available"}
        
        # Create a temporary file to store targets
        with tempfile.NamedTemporaryFile(mode='w+', delete=False) as tmp:
            for target in targets:
                tmp.write(f"{target}\n")
            targets_file = tmp.name
        
        # Prepare the command
        cmd = [self.nuclei_path, "-l", targets_file]
        
        # Add templates if specified
        if templates:
            for template in templates:
                cmd.extend(["-t", template])
        
        # Add severity filters if specified
        if severity:
            cmd.extend(["-severity", ",".join(severity)])
        
        # Set output format
        output_file = tempfile.NamedTemporaryFile(delete=False).name
        cmd.extend(["-o", output_file, "-json"])
        
        # Set rate limit
        cmd.extend(["-rate-limit", str(rate_limit)])
        
        # Add additional parameters
        for key, value in kwargs.items():
            if len(key) == 1:
                cmd.append(f"-{key}")
            else:
                cmd.append(f"-{key.replace('_', '-')}")
            
            if value is not True:  # Don't add value for boolean flags
                cmd.append(str(value))
        
        self.logger.info(f"Running Nuclei command: {' '.join(cmd)}")
        
        try:
            # Run the command
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            stdout, stderr = process.communicate(timeout=1800)  # 30-minute timeout
            
            # Process the results
            results = {
                "command": " ".join(cmd),
                "return_code": process.returncode,
                "vulnerabilities": []
            }
            
            # Check if there was an error
            if process.returncode != 0:
                results["error"] = stderr
                self.logger.error(f"Nuclei scan failed: {stderr}")
                return results
            
            # Process the output file
            try:
                # Read the JSON output
                if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
                    vulnerabilities = []
                    with open(output_file, 'r') as f:
                        for line in f:
                            try:
                                vuln = json.loads(line.strip())
                                vulnerabilities.append(vuln)
                            except json.JSONDecodeError as e:
                                self.logger.warning(f"Error parsing Nuclei output line: {e}")
                    
                    # Process the vulnerabilities
                    results["vulnerabilities"] = vulnerabilities
                    results["vulnerability_count"] = len(vulnerabilities)
                    
                    # Count by severity
                    severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
                    for vuln in vulnerabilities:
                        severity = vuln.get("info", {}).get("severity", "").lower()
                        if severity in severity_counts:
                            severity_counts[severity] += 1
                    
                    results["severity_counts"] = severity_counts
                    
                else:
                    self.logger.warning("Nuclei output file is empty or does not exist")
                    results["vulnerabilities"] = []
                    results["vulnerability_count"] = 0
                    results["severity_counts"] = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
                
            except Exception as e:
                self.logger.error(f"Error processing Nuclei output: {e}")
                results["error"] = f"Error processing Nuclei output: {str(e)}"
            
            # Clean up
            try:
                os.unlink(targets_file)
                os.unlink(output_file)
            except Exception as e:
                self.logger.warning(f"Error cleaning up temporary files: {e}")
            
            return results
            
        except subprocess.TimeoutExpired:
            self.logger.error("Nuclei scan timed out after 30 minutes")
            return {
                "command": " ".join(cmd),
                "error": "Scan timed out after 30 minutes",
                "vulnerabilities": []
            }
        except Exception as e:
            self.logger.error(f"Error running Nuclei scan: {e}")
            return {
                "command": " ".join(cmd),
                "error": str(e),
                "vulnerabilities": []
            }