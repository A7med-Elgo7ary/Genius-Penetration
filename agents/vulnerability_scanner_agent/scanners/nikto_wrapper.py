#!/usr/bin/env python3
"""
Wrapper for the Nikto web server scanner.
"""

import subprocess
import json
import os
import logging
from typing import List, Dict, Any, Optional
import tempfile
import re   # For regular expression matching in text output parsing

class NiktoScanner:
    """Wrapper for the Nikto web server scanner."""

    def __init__(self, nikto_path: str = "nikto", logger: Optional[logging.Logger] = None):
        """
        Initialize the Nikto scanner wrapper.

        Args:
            nikto_path: Path to the nikto.pl script or executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("nikto_scanner")
        self.nikto_path = nikto_path # Often 'nikto' if in PATH, or '/path/to/nikto.pl'
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if Nikto is installed and executable."""
        cmd = []
        if self.nikto_path.endswith(".pl"): # If it's a perl script
            cmd.append("perl")
        cmd.append(self.nikto_path)
        cmd.append("-Version")
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=False, timeout=15)
            # Nikto version info might be in stdout or stderr depending on the version
            combined_output = result.stdout + result.stderr
            
            # Check for Nikto version string in any output
            if "Nikto" in combined_output and any(x in combined_output.lower() for x in ["version", "scan", "2.5.0"]):
                self.logger.info(f"Nikto found: {result.stdout.strip()}")
                return True
            else:
                self.logger.warning(f"Nikto not found or not working correctly at {self.nikto_path}. stdout: {result.stdout}, stderr: {result.stderr}")
                return False
        except FileNotFoundError:
            self.logger.error(f"Nikto executable/script or perl not found. Command: {' '.join(cmd)}. Please install Nikto or provide the correct path.")
            return False
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout checking Nikto availability with command: {' '.join(cmd)}")
            return False
        except Exception as e:
            self.logger.error(f"Error checking Nikto availability: {e}")
            return False

    def _parse_nikto_json(self, json_output_file: str) -> Dict[str, Any]:
        """
        Parse Nikto JSON output.
        Nikto JSON output structure:
        {
            "host": "...", "ip": "...", "port": "...", "banner": "...",
            "vulnerabilities": [
                { "id": "...", "osvdbid": "...", "method": "...", "url": "...", "msg": "..." }
            ]
        }
        """
        parsed_data = {"vulnerabilities": [], "host_info": {}}
        try:
            with open(json_output_file, 'r') as f:
                # Nikto JSON output can be a single JSON object or a stream of them if multiple hosts/ports
                content = f.read()
                if not content.strip():
                    self.logger.warning("Nikto JSON output file is empty.")
                    return parsed_data
                
                # Try to parse as a single JSON object first
                try:
                    data = json.loads(content)
                    
                    parsed_data["host_info"] = {
                        "host": data.get("host"),
                        "ip": data.get("ip"),
                        "port": data.get("port"),
                        "banner": data.get("banner"),
                        "scan_start_time": data.get("starttime"),
                        "scan_end_time": data.get("endtime"),
                        "scan_elapsed": data.get("elapsed")
                    }
                    parsed_data["vulnerabilities"] = data.get("vulnerabilities", [])
                    
                except json.JSONDecodeError:
                    # If single JSON parse fails, try parsing line by line (Nikto might output JSON Lines format)
                    self.logger.info("Attempting to parse Nikto output as JSON Lines format")
                    with open(json_output_file, 'r') as f:
                        for line_num, line in enumerate(f):
                            line = line.strip()
                            if not line:
                                continue
                                
                            try:
                                line_data = json.loads(line)
                                
                                # If this is the first line, use it for host info
                                if line_num == 0 and not parsed_data["host_info"] and line_data.get("host"):
                                    parsed_data["host_info"] = {
                                        "host": line_data.get("host"),
                                        "ip": line_data.get("ip"),
                                        "port": line_data.get("port"),
                                        "banner": line_data.get("banner"),
                                        "scan_start_time": line_data.get("starttime"),
                                        "scan_end_time": line_data.get("endtime"),
                                        "scan_elapsed": line_data.get("elapsed")
                                    }
                                
                                # Add any vulnerabilities found
                                if "vulnerabilities" in line_data and isinstance(line_data["vulnerabilities"], list):
                                    parsed_data["vulnerabilities"].extend(line_data["vulnerabilities"])
                                    
                            except json.JSONDecodeError:
                                self.logger.debug(f"Skipping invalid JSON line: {line[:50]}...")
                    
                    if not parsed_data["host_info"] and not parsed_data["vulnerabilities"]:
                        self.logger.warning("Failed to parse Nikto output in any JSON format")
                        
        except Exception as e:
            self.logger.error(f"Error processing Nikto JSON output from {json_output_file}: {e}")
            
        return parsed_data

    def _parse_nikto_text_output(self, text_output: str, target_url: str) -> Dict[str, Any]:
        """
        Parse Nikto's text output when JSON parsing fails.
        This is a fallback method to extract vulnerability information from standard text output.
        
        Args:
            text_output: The standard output from Nikto
            target_url: Original target URL
            
        Returns:
            Parsed data in a structure similar to the JSON output
        """
        parsed_data = {"vulnerabilities": [], "host_info": {}}
        
        # Extract host info
        host_info = {
            "host": target_url,
            "ip": "",
            "port": "",
            "banner": ""
        }
        
        # Try to extract IP and port information
        ip_match = re.search(r"Target IP:\s+(\d+\.\d+\.\d+\.\d+)", text_output)
        if ip_match:
            host_info["ip"] = ip_match.group(1)
            
        port_match = re.search(r"Target Port:\s+(\d+)", text_output)
        if port_match:
            host_info["port"] = port_match.group(1)
            
        banner_match = re.search(r"Web Server:\s+([^\n]+)", text_output)
        if banner_match:
            host_info["banner"] = banner_match.group(1)
            
        parsed_data["host_info"] = host_info
        
        # Extract vulnerabilities
        # Nikto's text output typically has lines like "+ OSVDB-XXX: Path/file: Description"
        vuln_pattern = r"\+ ([^:]+):\s+(.+)"  # Will match OSVDB identifiers and descriptions
        
        for line in text_output.splitlines():
            if line.startswith("+") and ": " in line:
                try:
                    match = re.match(vuln_pattern, line)
                    if match:
                        vuln_id = match.group(1).strip()
                        description = match.group(2).strip()
                        
                        # Split out URL if present
                        url = ""
                        if ": " in description:
                            parts = description.split(": ", 1)
                            if len(parts) == 2:
                                url = parts[0].strip()
                                description = parts[1].strip()
                        
                        # Extract OSVDB ID if present
                        osvdb_id = ""
                        if "OSVDB-" in vuln_id:
                            osvdb_id = vuln_id.replace("OSVDB-", "").strip()
                            
                        vulnerability = {
                            "id": vuln_id,
                            "osvdbid": osvdb_id,
                            "method": "GET",  # Default to GET since text output usually doesn't specify
                            "url": url,
                            "msg": description
                        }
                        
                        parsed_data["vulnerabilities"].append(vulnerability)
                except Exception as e:
                    self.logger.debug(f"Error parsing vulnerability line: {line}. Error: {e}")
                    
        return parsed_data

    def scan(self, target_url: str, ports: Optional[str] = None,
             tuning_options: Optional[str] = None, # e.g., "12345"
             additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run a Nikto scan on the specified target URL.

        Args:
            target_url: Target URL (e.g., "http://example.com" or "example.com").
                        Nikto typically expects a hostname or IP. If URL, it extracts host.
            ports: Comma-separated list of ports (e.g., "80,443"). Default: 80.
            tuning_options: Nikto tuning options (-Tuning x). See Nikto docs.
                            0: File Upload
                            1: Interesting File / Seen in logs
                            2: Misconfiguration / Default File
                            3: Information Disclosure
                            4: Injection (XSS/Script/HTML)
                            5: Remote File Retrieval - Inside Web Root
                            6: Denial of Service
                            7: Remote File Retrieval - Server Wide
                            8: Command Execution / Remote Shell
                            9: SQL Injection
                            a: Authentication Bypass
                            b: Software Identification
                            c: Remote Source Inclusion
                            x: Reverse Tuning Options (i.e., include all except specified)
            additional_args: List of additional Nikto arguments.

        Returns:
            Dict containing scan results.
        """
        if not self.available:
            return {"error": "Nikto scanner not available."}

        results: Dict[str, Any] = {
            "target_url_scanned": target_url,
            "scan_data": {},
            "error": None,
            "raw_json_file": None,
            "command_used": ""
        }

        # Extract host from URL if ports are specified or full URL is given
        host = target_url
        host_only = target_url
        use_host_only = False
        
        # If ports are specified, we need to extract the hostname only (not the full URL)
        if ports:
            use_host_only = True
        
        # Extract hostname if needed
        if "://" in target_url:
            # Extract hostname without protocol and path
            host_only = target_url.split("://")[1].split("/")[0].split(":")[0]
            
        # Use hostname only if ports are specified, otherwise use full URL
        if use_host_only:
            self.logger.info(f"Using hostname only for Nikto scan with port {ports}: {host_only}")
            host = host_only
        else:
            self.logger.info(f"Using full URL for Nikto scan: {host}")
        
        json_output_file = None
        try:
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".json") as tmp_json:
                json_output_file = tmp_json.name

            cmd = []
            if self.nikto_path.endswith(".pl"):
                cmd.append("perl")
            cmd.append(self.nikto_path)
            cmd.extend(["-h", host])
            
            # Add -useproxy and -followredirects for better results
            cmd.extend(["-useproxy", "-followredirects"])
            
            # Set format to JSON and enable display
            cmd.extend(["-Format", "json", "-Display", "V", "-o", json_output_file])

            if ports:
                cmd.extend(["-p", ports])
            if tuning_options:
                cmd.extend(["-Tuning", tuning_options])
            if additional_args:
                cmd.extend(additional_args)
            
            results["command_used"] = " ".join(cmd)
            self.logger.info(f"Running Nikto command: {results['command_used']}")

            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate(timeout=1800) # 30-minute timeout

            if stdout: # Nikto often prints summary to stdout even with -o
                self.logger.info(f"Nikto stdout: {stdout.strip()}")
            if stderr:
                self.logger.warning(f"Nikto stderr: {stderr.strip()}")
                if "ERROR" in stderr.upper() or "FATAL" in stderr.upper():
                    results["error"] = stderr.strip()

            if process.returncode != 0 and not results["error"]:
                results["error"] = f"Nikto process exited with code {process.returncode}. Stderr: {stderr.strip()}"
                self.logger.error(f"Nikto process failed. stdout: {stdout}, stderr: {stderr}")

            # Check for output file and attempt to parse
            if os.path.exists(json_output_file) and os.path.getsize(json_output_file) > 0:
                results["scan_data"] = self._parse_nikto_json(json_output_file)
                results["raw_json_file"] = json_output_file
            elif stdout and "-" in stdout and "*" in stdout:  # Typical Nikto output markers
                # Convert stdout to a structured format if JSON failed
                self.logger.info("Parsing Nikto text output as JSON failed, converting stdout")
                parsed_text_data = self._parse_nikto_text_output(stdout, target_url)
                results["scan_data"] = parsed_text_data
                
                # Write the parsed data to the JSON file for future reference
                try:
                    with open(json_output_file, 'w') as f:
                        json.dump(parsed_text_data, f)
                    results["raw_json_file"] = json_output_file
                except Exception as e:
                    self.logger.warning(f"Failed to save parsed Nikto output to JSON: {e}")
            elif not results["error"]:
                results["error"] = "Nikto did not produce any usable output."
                self.logger.warning(results["error"])
                
            return results

        except subprocess.TimeoutExpired:
            self.logger.error(f"Nikto scan timed out for target: {target_url}")
            results["error"] = "Nikto scan timed out."
            return results
        except Exception as e:
            self.logger.error(f"Error running Nikto scan: {e}")
            results["error"] = str(e)
            return results
        # Not deleting json_output_file here for now.

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(levelname)s: %(message)s')
    scanner = NiktoScanner()

    if scanner.available:
        # test_target = "scanme.nmap.org"
        # test_target = "http://testphp.vulnweb.com"
        test_target = "http://localhost" # Test against a local web server

        print(f"Scanning target: {test_target}")
        # scan_results = scanner.scan(test_target, ports="80", tuning_options="123b")
        scan_results = scanner.scan(test_target, ports="80")


        print("\nScan Results:")
        if scan_results.get("error"):
            print(f"  Error: {scan_results['error']}")
        
        if scan_results.get("scan_data", {}).get("vulnerabilities"):
            print(f"  Host Info: {scan_results['scan_data'].get('host_info')}")
            print("  Vulnerabilities Found:")
            for vuln in scan_results["scan_data"]["vulnerabilities"][:5]: # Print first 5
                print(f"    - ID: {vuln.get('id', 'N/A')}, OSVDBID: {vuln.get('osvdbid', 'N/A')}, URL: {vuln.get('url')}, MSG: {vuln.get('msg')}")
            if len(scan_results["scan_data"]["vulnerabilities"]) > 5:
                print(f"    ... and {len(scan_results['scan_data']['vulnerabilities']) - 5} more.")
        else:
            print("  No vulnerabilities found or scan data not processed.")
            if scan_results.get("scan_data"): print(f"  Raw scan data: {scan_results.get('scan_data')}")

        if scan_results.get("raw_json_file"):
            print(f"  Raw JSON output potentially at: {scan_results.get('raw_json_file')}")
            # Nikto might also create .ndj files in the same directory as -o if -Save is used.
        
        print(f"  Command: {scan_results.get('command_used')}")

        # print("\nFull JSON Output:")
        # print(json.dumps(scan_results, indent=2))
    else:
        print("Nikto scanner is not available.")