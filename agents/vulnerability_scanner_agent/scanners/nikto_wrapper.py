#!/usr/bin/env python3
"""
Wrapper for the Nikto web server scanner.
"""

import subprocess
import json
import os
import logging
from typing import List, Dict, Any, Optional
import tempfile

class NiktoScanner:
    """Wrapper for the Nikto web server scanner."""

    def __init__(self, nikto_path: str = "nikto", logger: Optional[logging.Logger] = None):
        """
        Initialize the Nikto scanner wrapper.

        Args:
            nikto_path: Path to the nikto.pl script or executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("nikto_scanner")
        self.nikto_path = nikto_path # Often 'nikto' if in PATH, or '/path/to/nikto.pl'
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if Nikto is installed and executable."""
        cmd = []
        if self.nikto_path.endswith(".pl"): # If it's a perl script
            cmd.append("perl")
        cmd.append(self.nikto_path)
        cmd.append("-Version")
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=False, timeout=15)
            # Nikto version info is usually in stderr
            if "Nikto" in result.stderr and ("version" in result.stderr.lower() or "scan" in result.stderr.lower()):
                self.logger.info(f"Nikto found: {result.stderr.strip().splitlines()[0]}")
                return True
            else:
                self.logger.warning(f"Nikto not found or not working correctly at {self.nikto_path}. stdout: {result.stdout}, stderr: {result.stderr}")
                return False
        except FileNotFoundError:
            self.logger.error(f"Nikto executable/script or perl not found. Command: {' '.join(cmd)}. Please install Nikto or provide the correct path.")
            return False
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout checking Nikto availability with command: {' '.join(cmd)}")
            return False
        except Exception as e:
            self.logger.error(f"Error checking Nikto availability: {e}")
            return False

    def _parse_nikto_json(self, json_output_file: str) -> Dict[str, Any]:
        """
        Parse Nikto JSON output.
        Nikto JSON output structure:
        {
            "host": "...", "ip": "...", "port": "...", "banner": "...",
            "vulnerabilities": [
                { "id": "...", "osvdbid": "...", "method": "...", "url": "...", "msg": "..." }
            ]
        }
        """
        parsed_data = {"vulnerabilities": [], "host_info": {}}
        try:
            with open(json_output_file, 'r') as f:
                # Nikto JSON output can be a single JSON object or a stream of them if multiple hosts/ports
                # For a single scan, it's usually one object.
                content = f.read()
                if not content.strip():
                    self.logger.warning("Nikto JSON output file is empty.")
                    return parsed_data
                
                # Nikto might output multiple JSON objects if scanning multiple ports/hosts in one go
                # For simplicity, this wrapper expects one main target, so one JSON object.
                data = json.loads(content) 
                
            parsed_data["host_info"] = {
                "host": data.get("host"),
                "ip": data.get("ip"),
                "port": data.get("port"),
                "banner": data.get("banner"),
                "scan_start_time": data.get("starttime"),
                "scan_end_time": data.get("endtime"),
                "scan_elapsed": data.get("elapsed")
            }
            parsed_data["vulnerabilities"] = data.get("vulnerabilities", [])
        except json.JSONDecodeError as e:
            self.logger.error(f"Error decoding Nikto JSON output from {json_output_file}: {e}")
            # Try to read line by line if it's a stream
            try:
                with open(json_output_file, 'r') as f:
                    for line in f:
                        if line.strip():
                            data = json.loads(line)
                            # Simplified aggregation for stream
                            if "vulnerabilities" in data:
                                parsed_data["vulnerabilities"].extend(data.get("vulnerabilities", []))
                            if not parsed_data["host_info"] and "host" in data : # take first host info
                                 parsed_data["host_info"] = { "host": data.get("host"), "ip": data.get("ip"), "port": data.get("port")}

            except Exception as e_stream:
                 self.logger.error(f"Further error decoding Nikto JSON stream: {e_stream}")

        except Exception as e:
            self.logger.error(f"Unexpected error parsing Nikto JSON {json_output_file}: {e}")
        return parsed_data

    def scan(self, target_url: str, ports: Optional[str] = None,
             tuning_options: Optional[str] = None, # e.g., "12345"
             additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run a Nikto scan on the specified target URL.

        Args:
            target_url: Target URL (e.g., "http://example.com" or "example.com").
                        Nikto typically expects a hostname or IP. If URL, it extracts host.
            ports: Comma-separated list of ports (e.g., "80,443"). Default: 80.
            tuning_options: Nikto tuning options (-Tuning x). See Nikto docs.
                            0: File Upload
                            1: Interesting File / Seen in logs
                            2: Misconfiguration / Default File
                            3: Information Disclosure
                            4: Injection (XSS/Script/HTML)
                            5: Remote File Retrieval - Inside Web Root
                            6: Denial of Service
                            7: Remote File Retrieval - Server Wide
                            8: Command Execution / Remote Shell
                            9: SQL Injection
                            a: Authentication Bypass
                            b: Software Identification
                            c: Remote Source Inclusion
                            x: Reverse Tuning Options (i.e., include all except specified)
            additional_args: List of additional Nikto arguments.

        Returns:
            Dict containing scan results.
        """
        if not self.available:
            return {"error": "Nikto scanner not available."}

        results: Dict[str, Any] = {
            "target_url_scanned": target_url,
            "scan_data": {},
            "error": None,
            "raw_json_file": None,
            "command_used": ""
        }

        # Extract host from URL if full URL is given
        host = target_url
        if "://" in target_url:
            host = target_url.split("://")[1].split("/")[0].split(":")[0]
        
        json_output_file = None
        try:
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".json") as tmp_json:
                json_output_file = tmp_json.name

            cmd = []
            if self.nikto_path.endswith(".pl"):
                cmd.append("perl")
            cmd.append(self.nikto_path)
            cmd.extend(["-h", host])
            cmd.extend(["-Format", "json", "-o", json_output_file, "-Save", os.path.dirname(json_output_file)]) # Save dir for potential ndj files

            if ports:
                cmd.extend(["-p", ports])
            if tuning_options:
                cmd.extend(["-Tuning", tuning_options])
            if additional_args:
                cmd.extend(additional_args)
            
            results["command_used"] = " ".join(cmd)
            self.logger.info(f"Running Nikto command: {results['command_used']}")

            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate(timeout=1800) # 30-minute timeout

            if stdout: # Nikto often prints summary to stdout even with -o
                self.logger.info(f"Nikto stdout: {stdout.strip()}")
            if stderr:
                self.logger.warning(f"Nikto stderr: {stderr.strip()}")
                if "ERROR" in stderr.upper() or "FATAL" in stderr.upper():
                    results["error"] = stderr.strip()

            if process.returncode != 0 and not results["error"]:
                results["error"] = f"Nikto process exited with code {process.returncode}. Stderr: {stderr.strip()}"
                self.logger.error(f"Nikto process failed. stdout: {stdout}, stderr: {stderr}")

            if os.path.exists(json_output_file) and os.path.getsize(json_output_file) > 0:
                results["scan_data"] = self._parse_nikto_json(json_output_file)
                results["raw_json_file"] = json_output_file
            elif not results["error"]:
                results["error"] = "Nikto did not produce a JSON output file or it was empty."
                self.logger.warning(results["error"])
                
            return results

        except subprocess.TimeoutExpired:
            self.logger.error(f"Nikto scan timed out for target: {target_url}")
            results["error"] = "Nikto scan timed out."
            return results
        except Exception as e:
            self.logger.error(f"Error running Nikto scan: {e}")
            results["error"] = str(e)
            return results
        # Not deleting json_output_file here for now.

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(levelname)s: %(message)s')
    scanner = NiktoScanner()

    if scanner.available:
        # test_target = "scanme.nmap.org"
        # test_target = "http://testphp.vulnweb.com"
        test_target = "http://localhost" # Test against a local web server

        print(f"Scanning target: {test_target}")
        # scan_results = scanner.scan(test_target, ports="80", tuning_options="123b")
        scan_results = scanner.scan(test_target, ports="80")


        print("\nScan Results:")
        if scan_results.get("error"):
            print(f"  Error: {scan_results['error']}")
        
        if scan_results.get("scan_data", {}).get("vulnerabilities"):
            print(f"  Host Info: {scan_results['scan_data'].get('host_info')}")
            print("  Vulnerabilities Found:")
            for vuln in scan_results["scan_data"]["vulnerabilities"][:5]: # Print first 5
                print(f"    - ID: {vuln.get('id', 'N/A')}, OSVDBID: {vuln.get('osvdbid', 'N/A')}, URL: {vuln.get('url')}, MSG: {vuln.get('msg')}")
            if len(scan_results["scan_data"]["vulnerabilities"]) > 5:
                print(f"    ... and {len(scan_results['scan_data']['vulnerabilities']) - 5} more.")
        else:
            print("  No vulnerabilities found or scan data not processed.")
            if scan_results.get("scan_data"): print(f"  Raw scan data: {scan_results.get('scan_data')}")

        if scan_results.get("raw_json_file"):
            print(f"  Raw JSON output potentially at: {scan_results.get('raw_json_file')}")
            # Nikto might also create .ndj files in the same directory as -o if -Save is used.
        
        print(f"  Command: {scan_results.get('command_used')}")

        # print("\nFull JSON Output:")
        # print(json.dumps(scan_results, indent=2))
    else:
        print("Nikto scanner is not available.")