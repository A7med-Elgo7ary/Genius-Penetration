#!/usr/bin/env python3
"""
Wrapper for the Masscan port scanner.
"""

import subprocess
import json
import os
import logging
from typing import List, Dict, Any, Optional
import tempfile

class MasscanScanner:
    """Wrapper for the Masscan port scanner."""
    
    def __init__(self, masscan_path: str = "masscan", logger: Optional[logging.Logger] = None):
        """
        Initialize the Masscan scanner wrapper.

        Args:
            masscan_path: Path to the masscan executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("masscan_scanner")
        self.masscan_path = masscan_path
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if Masscan is installed and executable."""
        try:
            # Check if masscan exists at the standard system path
            if os.path.exists('/usr/bin/masscan'):
                self.masscan_path = '/usr/bin/masscan'
                self.logger.info(f"Using system Masscan at {self.masscan_path}")
                
            result = subprocess.run([self.masscan_path, "--version"], 
                               stdout=subprocess.PIPE, 
                               stderr=subprocess.PIPE,
                               text=True, check=False)
            combined_output = result.stdout + result.stderr
            
            if result.returncode == 0 or "Masscan version" in combined_output or "masscan/" in combined_output:
                self.logger.info(f"Masscan found: {combined_output.strip().splitlines()[0] if combined_output.strip() else 'version unknown'}")
                return True
            else:
                self.logger.warning(f"Masscan not found or not working correctly at {self.masscan_path}. Output: {combined_output[:200]}")
                return False
        except FileNotFoundError:
            self.logger.error(f"Masscan executable not found at {self.masscan_path}. Please install Masscan or provide the correct path.")
            return False
        except Exception as e:
            self.logger.error(f"Error checking Masscan availability: {e}")
            return False
    
    def scan(self, targets: List[str], ports: str = "1-1000", 
             rate: int = 1000, interface: Optional[str] = None,
             additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run a Masscan scan on the specified targets.
        
        Args:
            targets: List of IP addresses or CIDR ranges to scan.
            ports: Comma-separated list of ports/port ranges (e.g., "80,443,8000-8100", "0-65535").
            rate: Packet rate in packets per second.
            interface: Network interface to use for scanning.
            additional_args: List of additional arguments to pass to masscan.
            
        Returns:
            Dict containing scan results (list of open ports per IP).
        """
        if not self.available:
            return {"error": "Masscan scanner not available."}
            
        if not targets:
            return {"error": "No targets provided for Masscan scan."}
        
        # Use a more reasonable default port range to avoid scanning all 65535 ports
        if ports == "0-65535":
            ports = "1-1000"  # Common ports are more likely to be interesting
            
        results: Dict[str, Any] = {
            "targets_scanned": targets,
            "ports_scanned": ports,
            "summary": "Masscan port scan results",
            "vulnerabilities": [],
            "vulnerability_counts": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0
            },
            "findings": [],
            "errors": []
        }

        # Masscan prefers targets in a file for large scans, but can take them on cmd line too.
        # For simplicity with potentially few targets from LLM, direct CLI is fine.
        # If scanning very large ranges, using a target file (-iL) would be better.
        
        output_file = None
        try:
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".json") as tmp_output:
                output_file = tmp_output.name

            # Build command - Masscan prefers non-root operation with --unprivileged flag
            cmd = [self.masscan_path]
            cmd.extend(targets) # Add targets directly
            cmd.extend(["-p", ports])
            cmd.extend(["--rate", str(rate)])
            cmd.extend(["--unprivileged"])  # Run without requiring root
            cmd.extend(["-oJ", output_file]) # Output in JSON format

            if interface:
                cmd.extend(["-i", interface])
            
            if additional_args:
                cmd.extend(additional_args)
            
            # Construct the command string for reporting
            command_str = ' '.join(cmd)
            results["command_used"] = command_str
            self.logger.info(f"Running Masscan command: {command_str}")
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            stdout, stderr = process.communicate(timeout=1800) # 30-minute timeout (scans can be long)
            
            if stderr and not results["errors"]:  # Masscan outputs progress to stderr, filter errors
                # Check for permission errors which are common with Masscan
                if "Permission denied" in stderr or "operation not permitted" in stderr.lower():
                    error_msg = "Masscan requires root privileges. Try running with sudo or use --unprivileged flag."
                    self.logger.error(error_msg)
                    results["errors"].append(error_msg)
                    # Provide helpful information in the summary
                    results["summary"] = "Masscan requires elevated privileges. Scan could not be completed."
                # Get important errors only
                error_lines = [line for line in stderr.splitlines() if "[ERROR]" in line or "error" in line.lower()]
                if error_lines:
                    self.logger.error(f"Masscan stderr errors: {'; '.join(error_lines)}")
                    results["errors"].extend(error_lines)
            
            # If non-zero exit code and not already logged an error
            if process.returncode != 0 and not results["errors"]:
                self.logger.error(f"Masscan returned non-zero exit code: {process.returncode}")
                results["errors"].append(f"Masscan exited with code {process.returncode}")
                results["summary"] = "Masscan scan failed with a non-zero exit code."
            
            # Parse output file if it exists and has content
            if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
                with open(output_file, 'r') as f:
                    content = f.read().strip()
                    
                # Strip trailing commas which can break JSON parsing
                if content.endswith(","):
                    content = content.rstrip(",")
                    
                # Add brackets if they're missing (Masscan output might be line-per-JSON-object)
                if not (content.startswith("[") and content.endswith("]")):
                    content = "[" + content + "]"
                    
                # Parse the JSON
                try:
                    parsed_findings = json.loads(content)
                except json.JSONDecodeError as e:
                    self.logger.warning(f"Error parsing Masscan JSON output: {e}")
                    
                    # Try line-by-line parsing as fallback
                    parsed_findings = []
                    for line in content.strip("[]").split("\n"):
                        if line.strip():
                            try:
                                parsed_findings.append(json.loads(line.rstrip(',')))
                            except json.JSONDecodeError as e_line:
                                self.logger.warning(f"Skipping malformed JSON line from Masscan: {line} - Error: {e_line}")
                        f.seek(0) # Reset file pointer
                        parsed_findings = []
                        for line in f:
                            line = line.strip()
                            if line: # Ensure line is not empty
                                try:
                                    # Masscan sometimes adds a comma at the end of lines if it expects more output.
                                    parsed_findings.append(json.loads(line.rstrip(',')))
                                except json.JSONDecodeError as e_line:
                                    self.logger.warning(f"Skipping malformed JSON line from Masscan: {line} - Error: {e_line}")
                
                # Structure the findings
                # Masscan output is like: {"ip": "x.x.x.x", "timestamp": "123", "ports": [ {"port": 80, "proto": "tcp", "status": "open", "reason": "syn-ack", "ttl": 64} ] }
                for entry in parsed_findings:
                    if "ip" in entry and "ports" in entry:
                        for port_info in entry["ports"]:
                            findings_item = {
                                "ip": entry["ip"],
                                "port": port_info["port"],
                                "protocol": port_info["proto"],
                                "status": port_info.get("status", "open") # status might not always be present
                            }
                            results["findings"].append(findings_item)
                            
                            # For commonly exposed ports, create vulnerability entries
                            # This helps ensure Masscan results appear in the vulnerability report
                            port_number = port_info["port"]
                            if port_number in [21, 22, 23, 25, 53, 80, 443, 3389, 8080, 8443]:
                                vuln_name = f"Open {port_info['proto'].upper()} port {port_number}"
                                severity = "low"
                                
                                # Adjust severity based on service risk level
                                if port_number in [21, 23, 3389]:  # FTP, Telnet, RDP
                                    severity = "medium"
                                
                                vuln = {
                                    "name": vuln_name,
                                    "severity": severity,
                                    "description": f"Port {port_number} ({port_info['proto']}) is open on {entry['ip']}, which could potentially expose services to unauthorized access.",
                                    "impact": f"Open ports may expose services that could be vulnerable to attacks.",
                                    "remediation": f"Verify whether port {port_number} needs to be exposed and implement appropriate access controls if required.",
                                    "affected_targets": [entry['ip']],
                                    "is_likely_false_positive": False
                                }
                                
                                results["vulnerabilities"].append(vuln)
                                results["vulnerability_counts"][severity] += 1
                                
                # Update the summary based on the findings
                if results["findings"]:
                    results["summary"] = f"Masscan found {len(results['findings'])} open ports across {len(set(f['ip'] for f in results['findings']))} IP addresses."
                elif not results["errors"]:
                    results["summary"] = "Masscan completed successfully but found no open ports on the scanned targets."
            elif not results["errors"]: # If no errors but also no output file / empty output
                results["summary"] = "Masscan produced no output. This may indicate no open ports were found."
                self.logger.warning("Masscan produced no output or output file is empty.")
                # This can happen if no open ports are found, which is not an error.

            # Format the results in the way expected by the vulnerability scanner
            # Include raw data for potential future analysis
            results["raw_data"] = {"note": "Original scanner output stored internally"}
            
            return results
            
        except subprocess.TimeoutExpired:
            self.logger.error("Masscan scan timed out after 30 minutes.")
            results["errors"].append("Masscan scan timed out.")
            return results
        except Exception as e:
            self.logger.error(f"Error running Masscan scan: {e}")
            results["errors"].append(f"Unexpected error: {str(e)}")
            return results
        finally:
            if output_file and os.path.exists(output_file):
                try:
                    os.unlink(output_file)
                except Exception as e_unlink:
                    self.logger.warning(f"Could not delete temporary masscan output file {output_file}: {e_unlink}")


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(levelname)s: %(message)s')
    
    # Requires Masscan to be installed and sudo/root if not using --unprivileged
    # On Kali, masscan is usually in /usr/bin/masscan
    scanner = MasscanScanner()

    if scanner.available:
        # Make sure you have permission to scan these targets.
        # Using scanme.nmap.org for testing.
        test_targets = ["scanme.nmap.org"] 
        # For local testing (if you have a local server running on these ports):
        # test_targets = ["127.0.0.1"]
        
        test_ports = "80,443,22" 
        # test_ports = "1-1000" # A common range

        print(f"Scanning targets: {test_targets} on ports: {test_ports}")
        # Note: Masscan can be very fast and aggressive. Use with caution on external networks.
        # The `rate` parameter is crucial.
        # For external scans, a lower rate like 100-500 might be advisable to avoid issues.
        scan_results = scanner.scan(test_targets, ports=test_ports, rate=100) 
        
        print("\nScan Results:")
        if scan_results["errors"]:
            print("Errors:")
            for err in scan_results["errors"]:
                print(f"  - {err}")
        
        if scan_results["findings"]:
            print("Open Ports Found:")
            for finding in scan_results["findings"]:
                print(f"  - IP: {finding['ip']}, Port: {finding['port']}, Protocol: {finding['protocol']}, Status: {finding['status']}")
        else:
            print("No open ports found or scan failed to produce results.")
            
        # import json
        # print("\nFull JSON Output:")
        # print(json.dumps(scan_results, indent=2))
    else:
        print("Masscan scanner is not available. Please install Masscan or check the path.")