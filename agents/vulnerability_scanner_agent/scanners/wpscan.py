#!/usr/bin/env python3
"""
Wrapper for the WPScan WordPress vulnerability scanner.
"""

import subprocess
import json
import os
import logging
from typing import List, Dict, Any, Optional
import tempfile

class WPScanRunner: # Renamed from WPScan to WPScanRunner to match your class name
    """Wrapper for the WPScan WordPress vulnerability scanner."""

    def __init__(self, wpscan_path: str = "wpscan", logger: Optional[logging.Logger] = None):
        """
        Initialize the WPScan wrapper.

        Args:
            wpscan_path: Path to the wpscan executable (usually a Ruby script).
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("wpscan_runner")
        self.wpscan_path = wpscan_path
        self.api_token = os.getenv('WPSCAN_API_TOKEN') # Get API token from environment
        if not self.api_token:
            self.logger.warning("WPSCAN_API_TOKEN not found in environment. Vulnerability data may be outdated or incomplete.")
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if WPScan is installed and executable."""
        # WPScan is a Ruby gem. The command is usually just 'wpscan'.
        cmd = [self.wpscan_path, "--version"]
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=False, timeout=20)
            # Version info is typically in stdout
            if "WordPress Security Scanner" in result.stdout and "version" in result.stdout.lower():
                self.logger.info(f"WPScan found: {result.stdout.strip().splitlines()[0]}")
                return True
            elif "WordPress Security Scanner" in result.stderr and "version" in result.stderr.lower(): # sometimes in stderr
                self.logger.info(f"WPScan found: {result.stderr.strip().splitlines()[0]}")
                return True
            else:
                self.logger.warning(f"WPScan not found or not working correctly at {self.wpscan_path}. stdout: {result.stdout}, stderr: {result.stderr}")
                return False
        except FileNotFoundError:
            self.logger.error(f"WPScan executable not found at {self.wpscan_path}. Please install WPScan (gem install wpscan) or provide the correct path.")
            return False
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout checking WPScan availability with command: {' '.join(cmd)}")
            return False
        except Exception as e:
            self.logger.error(f"Error checking WPScan availability: {e}")
            return False

    def _parse_wpscan_json(self, json_output: str) -> Dict[str, Any]:
        """
        Parse WPScan JSON output string.
        """
        try:
            data = json.loads(json_output)
            return data
        except json.JSONDecodeError as e:
            self.logger.error(f"Error decoding WPScan JSON output: {e}. Output was: {json_output[:500]}...")
            return {"error": "Failed to parse WPScan JSON output", "raw_output_snippet": json_output[:500]}

    def scan(self, target_url: str, enumeration_options: Optional[str] = "vt,vp,tt,cb,dbe,u,m", # Common sensible defaults
             api_token: Optional[str] = None,
             additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run a WPScan scan on the specified WordPress target URL.

        Args:
            target_url: Target WordPress URL (e.g., "http://example-wp.com").
            enumeration_options: Comma-separated list of items to enumerate.
                                 vt: Vulnerable themes
                                 vp: Vulnerable plugins
                                 ap: All plugins
                                 at: All themes
                                 tt: Timthumbs
                                 cb: Config backups
                                 dbe: DB exports
                                 u: User IDs range (e.g., u1-5)
                                 m: Media file uploads
                                 Default: "vt,vp,tt,cb,dbe,u,m" (common checks for vulnerabilities and users)
            api_token: WPScan API token for vulnerability data. Overrides environment variable if provided.
            additional_args: List of additional WPScan arguments.

        Returns:
            Dict containing scan results (parsed JSON from WPScan).
        """
        if not self.available:
            return {"error": "WPScan scanner not available."}

        final_api_token = api_token or self.api_token

        results: Dict[str, Any] = {
            "target_url_scanned": target_url,
            "scan_data": {},
            "error": None,
            "command_used": ""
        }
        
        # WPScan outputs JSON to stdout when --format json is used.
        # No need for a temporary file for the main output.
        cmd = [self.wpscan_path, "--url", target_url, "--format", "json", "--disable-tls-checks"] # Disable TLS for flexibility, LLM can override

        if final_api_token:
            cmd.extend(["--api-token", final_api_token])
        
        if enumeration_options:
            cmd.extend(["--enumerate", enumeration_options])
            
        if additional_args:
            cmd.extend(additional_args)
        
        results["command_used"] = " ".join(cmd)
        self.logger.info(f"Running WPScan command: {results['command_used']}")

        try:
            # WPScan can take some time.
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, errors='replace')
            stdout, stderr = process.communicate(timeout=1800) # 30-minute timeout

            if stderr:
                self.logger.warning(f"WPScan stderr: {stderr.strip()}")
                # WPScan often prints non-critical info to stderr (like update checks)
                # However, if stdout is empty and stderr has errors, it's a problem.
                if "[!]" in stderr or "Error" in stderr or "Traceback" in stderr:
                     if not stdout.strip() or stdout.strip() == "null": # If no valid JSON output
                        results["error"] = f"WPScan error: {stderr.strip()}"

            if process.returncode != 0 and not results["error"]:
                results["error"] = f"WPScan process exited with code {process.returncode}. Stderr: {stderr.strip()}"
                self.logger.error(f"WPScan process failed. stdout: {stdout}, stderr: {stderr}")
            
            if stdout.strip() and stdout.strip() != "null":
                results["scan_data"] = self._parse_wpscan_json(stdout)
                if results["scan_data"].get("error") and not results["error"]: # if parser set an error
                    results["error"] = results["scan_data"]["error"]
            elif not results["error"]:
                results["error"] = "WPScan did not produce JSON output or it was empty/null."
                self.logger.warning(results["error"] + f" Stderr was: {stderr.strip()}")
            
            return results

        except subprocess.TimeoutExpired:
            self.logger.error(f"WPScan scan timed out for target: {target_url}")
            results["error"] = "WPScan scan timed out."
            return results
        except Exception as e:
            self.logger.error(f"Error running WPScan scan: {e}")
            results["error"] = str(e)
            return results


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(levelname)s: %(message)s')
    
    # Ensure WPSCAN_API_TOKEN is set in your environment for best results
    if not os.getenv('WPSCAN_API_TOKEN'):
        print("Warning: WPSCAN_API_TOKEN environment variable not set. Vulnerability data might be limited.")
        print("You can get a free API token from https://wpscan.com/api")

    scanner = WPScanRunner()

    if scanner.available:
        # test_target_wp = "http://my-wordpress-site.com" # Replace with a test WordPress site you have permission to scan
        # For local testing, if you have a WordPress dev site:
        test_target_wp = "http://localhost/wordpress" # Example path
        # test_target_wp = "https://wpvulndb.com" # This site itself is not WP, but wpscan will say so.
                                                # Better to use an actual WP site.

        print(f"Scanning WordPress target: {test_target_wp}")
        # Default enumeration: "vt,vp,tt,cb,dbe,u,m"
        # scan_results = scanner.scan(test_target_wp, enumeration_options="vp,vt,u1-5") # Vulnerable plugins, themes, users 1-5
        scan_results = scanner.scan(test_target_wp)


        print("\nScan Results:")
        if scan_results.get("error"):
            print(f"  Error: {scan_results['error']}")
        
        scan_data = scan_results.get("scan_data", {})
        if scan_data and not scan_data.get("error"): # Check if scan_data itself doesn't contain a parser error
            print(f"  Target URL: {scan_data.get('target_url')}")
            print(f"  Effective URL: {scan_data.get('effective_url')}")
            
            if scan_data.get("version"):
                version_info = scan_data["version"]
                print(f"  WordPress Version: {version_info.get('number')} (Status: {version_info.get('status')}, Confidence: {version_info.get('confidence')}%)")
                if version_info.get("vulnerabilities"):
                    print("    Version Vulnerabilities:")
                    for vuln in version_info["vulnerabilities"]:
                        print(f"      - {vuln.get('title')}")
            
            if scan_data.get("main_theme"):
                 theme_info = scan_data["main_theme"]
                 print(f"  Main Theme: {theme_info.get('slug')} (Version: {theme_info.get('version', {}).get('number', 'N/A')})")
                 if theme_info.get("vulnerabilities"):
                    print("    Theme Vulnerabilities:")
                    for vuln in theme_info["vulnerabilities"]:
                        print(f"      - {vuln.get('title')}")


            plugins = scan_data.get("plugins", {})
            if plugins:
                print("  Plugins Found:")
                for slug, plugin_info in list(plugins.items())[:3]: # Print first 3 plugins
                    print(f"    - {slug} (Version: {plugin_info.get('version', {}).get('number', 'N/A')}, Popularity: {plugin_info.get('popularity')}%)")
                    if plugin_info.get("vulnerabilities"):
                        print("      Plugin Vulnerabilities:")
                        for vuln in plugin_info["vulnerabilities"]:
                            print(f"        - {vuln.get('title')}")
                if len(plugins) > 3: print(f"    ... and {len(plugins)-3} more plugins.")

            users = scan_data.get("users", {})
            if users:
                print("  Users Found:")
                for user_id, user_info in list(users.items())[:3]: # Print first 3 users
                    print(f"    - ID: {user_id}, Login: {user_info.get('login')}, Display Name: {user_info.get('display_name')}")
                if len(users) > 3: print(f"    ... and {len(users)-3} more users.")
        elif scan_data.get("error"):
             print(f"  Error from WPScan JSON parser: {scan_data.get('error')}")
        else:
            print("  No detailed scan data processed or WPScan found no specific issues based on enumeration.")
            if scan_data: print(f"  Raw scan_data content: {str(scan_data)[:200]}...")

        print(f"\n  Command Used: {scan_results.get('command_used')}")
        
        # print("\nFull JSON Output from Wrapper:")
        # print(json.dumps(scan_results, indent=2, default=str))
    else:
        print("WPScan scanner is not available.")