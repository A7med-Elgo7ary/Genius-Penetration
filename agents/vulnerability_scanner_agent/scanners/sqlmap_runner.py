"""
Runner for the SQLMap automated SQL injection tool.
"""

import subprocess
import os
import logging
from typing import List, Dict, Any, Optional
import tempfile
import re
import json

class SQLMapRunner:
    """Runner for SQLMap to detect and exploit SQL injection vulnerabilities."""

    def __init__(self, sqlmap_path: str = "sqlmap", logger: Optional[logging.Logger] = None):
        """
        Initialize the SQLMap runner.

        Args:
            sqlmap_path: Path to the sqlmap.py script or sqlmap executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("sqlmap_runner")
        self.sqlmap_path = sqlmap_path # Often 'sqlmap' or 'sqlmap.py'
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if SQLMap is installed and executable."""
        # First, try a simpler direct approach with just the path
        try:
            # Verify path exists and is executable
            if os.path.exists("/usr/bin/sqlmap"):
                self.sqlmap_path = "/usr/bin/sqlmap"
                self.logger.info(f"SQLMap found at {self.sqlmap_path}")
                result = subprocess.run([self.sqlmap_path, "--version"], 
                                      capture_output=True, text=True, check=False, timeout=15)
                combined_output = result.stdout + result.stderr
                if "sqlmap" in combined_output.lower() or "#stable" in combined_output or any(char.isdigit() for char in combined_output):
                    self.logger.info(f"SQLMap version: {result.stdout.strip()}")
                    return True
        except Exception as e:
            self.logger.debug(f"Initial direct check failed: {e}")
        
        # Fall back to the original approach with different command variations
        cmd = []
        # SQLMap can be a direct executable or a python script
        if not self.sqlmap_path.endswith(".py") and not os.access(self.sqlmap_path, os.X_OK):
            # If not a .py script and not directly executable, try with python
             if os.access(self.sqlmap_path + ".py", os.X_OK) or os.path.exists(self.sqlmap_path + ".py"):
                 cmd.append("python3") # Or "python" depending on sqlmap version / system
                 cmd.append(self.sqlmap_path + ".py") # Assuming it's a python script
             else: # Try direct execution if path seems to imply it
                 cmd.append(self.sqlmap_path)
        elif self.sqlmap_path.endswith(".py"):
            cmd.append("python3")
            cmd.append(self.sqlmap_path)
        else: # Assume it's an executable in PATH
            cmd.append(self.sqlmap_path)

        cmd.append("--version")
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=False, timeout=15)
            # Look for SQLMap in any output and specifically recognize the version format like "1.9.4#stable"
            combined_output = result.stdout + result.stderr
            if "sqlmap" in combined_output.lower() or "#stable" in combined_output:
                self.logger.info(f"SQLMap found: {result.stdout.strip()}")
                return True
            else:
                self.logger.warning(f"SQLMap not found or not working correctly with cmd {' '.join(cmd)}. stdout: {result.stdout}, stderr: {result.stderr}")
                return False
        except FileNotFoundError:
            self.logger.error(f"SQLMap or python not found. Command: {' '.join(cmd)}. Please install SQLMap or provide the correct path.")
            return False
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout checking SQLMap availability with command: {' '.join(cmd)}")
            return False
        except Exception as e:
            self.logger.error(f"Error checking SQLMap availability: {e}")
            return False

    def _parse_sqlmap_output(self, output_text: str, log_file_path: Optional[str] = None) -> Dict[str, Any]:
        """
        Parse the SQLMap command line output to extract useful information.
        
        This is a simplified parser that extracts key information about potential 
        SQL injection vulnerabilities.
        
        Args:
            output_text: The raw output from running SQLMap.
            log_file_path: Optional path to a SQLMap log file for additional parsing.
            
        Returns:
            Dict with parsed information about any SQL injections found.
        """
        results = {
            "injection_found": False,
            "injection_points": [],
            "database_info": {},
            "extracted_data": {},
            "log_summary": [], # Key log entries
            "parameter_summary": {}, # What params were tested
            "error_messages": [] # Critical errors
        }
        
        # Parsing these is out of scope for simple wrapper, but LLM could be instructed.
        if log_file_path and os.path.exists(log_file_path):
            try:
                with open(log_file_path, 'r', errors='ignore') as lf:
                    log_content = lf.readlines()
                    # Extract key lines
                    for line in log_content:
                        if "[INFO] testing " in line or \
                           "[PAYLOAD]" in line or \
                           "[CRITICAL]" in line or \
                           "identified injection" in line or \
                           "is vulnerable" in line.lower():
                            results["log_summary"].append(line.strip())
            except Exception as e:
                self.logger.error(f"Error reading SQLMap log file: {e}")
        
        # Simple text-based checks for injection success/details
        # SQLMap outputs clear messaging on the terminal when it finds an injection point
        if "is vulnerable" in output_text.lower() or "parameter" in output_text.lower() and "injectable" in output_text.lower():
            results["injection_found"] = True
            
            # Find injection points and their details
            # SQLMap often formats injection findings like: Parameter: [param] ([place])
            # or more specifically "Parameter 'param' is vulnerable"
            parameter_match = re.findall(r"Parameter '[^']+' is vulnerable", output_text, re.IGNORECASE) or \
                              re.findall(r"Parameter: ([^\s]+)", output_text) or \
                              re.findall(r"Injectable parameter: (.+?)$", output_text, re.MULTILINE)
                        
            if parameter_match:
                for match in parameter_match:
                    param = match.strip("':")
                    # Find associated technique
                    technique_match = re.search(r"Technique: ([A-Z]+)", output_text, re.IGNORECASE)
                    technique = technique_match.group(1) if technique_match else "Unknown"
                    
                    injection_point = {
                        "parameter": param,
                        "technique": technique,
                        "injectable": True
                    }
                    
                    # Look for DBMS details
                    dbms_match = re.search(r"web application technology: ([^\n]+)", output_text, re.IGNORECASE) or \
                                re.search(r"back-end DBMS: ([^\n]+)", output_text, re.IGNORECASE)
                                
                    if dbms_match:
                        injection_point["dbms"] = dbms_match.group(1).strip()
                    
                    results["injection_points"].append(injection_point)
            
            # Extract any database information (if enumeration was performed)
            if "available databases" in output_text.lower():
                db_section = re.search(r"available databases \[(\d+)\]:\n(.*?)(?=\n\n)", output_text, re.DOTALL | re.IGNORECASE)
                if db_section:
                    db_list = [db.strip() for db in db_section.group(2).split("\n") if db.strip()]
                    results["database_info"]["databases"] = db_list
        
        # Parse for any tested parameters
        tested_params = re.findall(r"testing ([^']+?) [^\n]*?for[^\n]*?SQL[^\n]*?inject", output_text, re.IGNORECASE)
        if tested_params:
            for param in tested_params:
                param = param.strip("':")
                if param not in results["parameter_summary"]:
                    results["parameter_summary"][param] = {"tested": True}
        
        # Look for critical errors
        critical_lines = [line for line in output_text.splitlines() if "[CRITICAL]" in line or "Traceback (most recent call last)" in line]
        if critical_lines:
            results["error_messages"] = critical_lines
        
        return results
        
    def scan(self, target_url: str | List[str], data: Optional[str] = None,
         level: int = 1, risk: int = 1, check_dbms: bool = False,
         list_dbs: bool = False, current_db: bool = False,
         batch_mode: bool = True, # Essential for automation
         crawl_depth: Optional[int] = None,
         forms: bool = False,
         random_agent: bool = False,
         additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run SQLMap against a target URL.

        Args:
            target_url: The URL or list of URLs to test (e.g., "http://example.com/vuln.php?id=1").
            data: POST data string (e.g., "user=test&pass=test").
            level: Level of tests to perform (1-5, default 1).
            risk: Risk of tests to perform (1-3, default 1).
            check_dbms: Try to identify the DBMS (--dbms).
            list_dbs: Enumerate databases (--dbs).
            current_db: Get current database (--current-db).
            batch_mode: Never ask for user input, use default behavior.
            crawl_depth: Depth for crawling websites to discover more injection points (--crawl).
            forms: Test forms found on the website (--forms).
            random_agent: Use a random User-Agent for scanning (--random-agent).
            additional_args: List of additional SQLMap arguments.

        Returns:
            Dict containing scan results with standardized vulnerability reporting format.
        """
        if not self.available:
            return {"error": "SQLMap scanner not available."}

        results: Dict[str, Any] = {
            "target_url_scanned": target_url,
            "scan_output_summary": {},
            "full_stdout": None,
            "error": None,
            "command_used": "",
            "summary": "SQLMap scan results",
            "vulnerabilities": [],
            "vulnerability_counts": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0
            },
            "raw_data": {"note": "Original scanner output stored internally"}
        }
        
        output_dir = None
        log_file_path_guess = None
        
        try:
            # SQLMap creates an output directory based on target. We can specify one.
            # Using a temp directory for session files.
            output_dir = tempfile.mkdtemp(prefix="sqlmap_output_")
            # The log file will be inside this dir, sqlmap creates it.
            # Sanitizing target_url for directory naming is complex; let sqlmap handle it within output_dir.
            
            cmd = []
            if self.sqlmap_path.endswith(".py"):
                cmd.append("python3") # Or python
            cmd.append(self.sqlmap_path)

            # Handle single URL or list of URLs
            if isinstance(target_url, list):
                if not target_url:  # Empty list
                    return {"error": "No target URLs provided"}
                # SQLMap can only take one -u parameter, so we'll use the first URL
                # and will need to run separate scans for other URLs if needed
                cmd.extend(["-u", target_url[0]])
                # Log that we're only using the first URL
                if len(target_url) > 1:
                    self.logger.info(f"SQLMap can only scan one URL at a time. Using first URL: {target_url[0]}. {len(target_url)-1} other URLs will be ignored.")
                    results["error"] = f"SQLMap can only scan one URL at a time. Using first URL: {target_url[0]}. {len(target_url)-1} other URLs will be ignored."
            else:
                cmd.extend(["-u", target_url])
                
            cmd.extend(["--output-dir", output_dir]) # Store session files here

            if data:
                cmd.extend(["--data", data])
            
            cmd.extend(["--level", str(level)])
            cmd.extend(["--risk", str(risk)])

            # Add new parameters
            if crawl_depth is not None:
                cmd.extend(["--crawl", str(crawl_depth)])
                
            if forms:
                cmd.append("--forms")
                
            if random_agent:
                cmd.append("--random-agent")

            if batch_mode:
                cmd.append("--batch")
            
            # Specific actions
            if check_dbms:
                cmd.append("--dbms") # This flag alone doesn't do much without a value usually, --fingerprint is better
                if "--fingerprint" not in (additional_args or []): 
                    cmd.append("--fingerprint")
            if list_dbs:
                cmd.append("--dbs")
            if current_db:
                cmd.append("--current-db")
                
            # Always use these options for more reliable detection
            if additional_args is None or "--technique" not in " ".join(additional_args or []):
                cmd.extend(["--technique", "BEUSTQ"])  # All techniques
            
            if additional_args:
                cmd.extend(additional_args)
            
            results["command_used"] = " ".join(cmd)
            self.logger.info(f"Running SQLMap command: {results['command_used']}")

            # SQLMap can be very interactive if not in batch mode.
            # It also can take a very long time.
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, errors='replace')
            stdout, _ = process.communicate(timeout=3600) # 1 hour timeout, adjust as needed

            results["full_stdout"] = stdout
            
            # SQLMap usually exits 0 even if vulnerabilities are found.
            # Need to parse output.
            # The log file path is usually output_dir/sanitized_target/log
            # Finding the exact log file path sqlmap creates can be tricky.
            # We'll just look for a 'log' file in the output_dir structure.
            if os.path.exists(output_dir):
                for root, _, files in os.walk(output_dir):
                    if 'log' in files:
                        log_file_path_guess = os.path.join(root, 'log')
                        break
            
            results["scan_output_summary"] = self._parse_sqlmap_output(stdout, log_file_path_guess)
            
            # Format the output for the vulnerability report
            if results["scan_output_summary"].get("injection_found", False):
                # Add found SQL injections to the vulnerabilities list
                for inj_point in results["scan_output_summary"].get("injection_points", []):
                    vuln = {
                        "name": "SQL Injection Vulnerability",
                        "severity": "high",  # SQL injection is typically high severity
                        "description": f"SQL injection vulnerability found at parameter '{inj_point.get('parameter', 'unknown')}' using technique {inj_point.get('technique', 'unknown')}.",
                        "impact": "An attacker could potentially extract sensitive data, modify database content, or execute arbitrary commands on the database server.",
                        "remediation": "Use parameterized queries or prepared statements for all database operations. Implement input validation and sanitization for all user inputs.",
                        "affected_targets": [target_url] if not isinstance(target_url, list) else target_url,
                        "is_likely_false_positive": False
                    }
                    results["vulnerabilities"].append(vuln)
                    results["vulnerability_counts"]["high"] += 1
                
                # Update the summary based on findings
                results["summary"] = f"SQLMap found {len(results['vulnerabilities'])} SQL injection vulnerabilities in the target."
            else:
                # No SQL injections found
                results["summary"] = "SQLMap did not detect any SQL injection vulnerabilities in the target."
            
            if process.returncode != 0:
                 self.logger.warning(f"SQLMap process exited with code {process.returncode}. This might be ok or indicate an issue.")
                 # Don't set error yet, as output parsing is primary.

            if "Traceback" in stdout or "[CRITICAL] " in stdout:
                if not results["scan_output_summary"].get("injection_found"): # If no injection found despite critical error
                    results["error"] = "SQLMap reported a critical error or traceback. Check full_stdout."
                    critical_lines = [line for line in stdout.splitlines() if "[CRITICAL]" in line or "Traceback" in line]
                    self.logger.error(f"SQLMap critical error/traceback: {' '.join(critical_lines[:3])}")
                    results["summary"] = "SQLMap encountered an error during scanning. Please check the error details."

        except subprocess.TimeoutExpired:
            self.logger.error(f"SQLMap scan timed out for target: {target_url}")
            results["error"] = "SQLMap scan timed out."
            results["full_stdout"] = results.get("full_stdout", "") + "\n[INFO] Scan timed out."
            # Try to parse whatever output was captured before timeout
            results["scan_output_summary"] = self._parse_sqlmap_output(results.get("full_stdout", ""))
        except Exception as e:
            self.logger.error(f"Error running SQLMap scan: {e}")
            results["error"] = str(e)
        finally:
            if output_dir and os.path.exists(output_dir):
                # For debugging, you might want to keep this. For automation, clean up.
                # import shutil
                # shutil.rmtree(output_dir)
                # self.logger.info(f"Cleaned up SQLMap output directory: {output_dir}")
                results["output_dir_path"] = output_dir # Return path for potential manual inspection
        
        return results
