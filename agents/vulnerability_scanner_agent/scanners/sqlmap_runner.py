#!/usr/bin/env python3
"""
Runner for the SQLMap automated SQL injection tool.
"""

import subprocess
import os
import logging
from typing import List, Dict, Any, Optional
import tempfile
import re
import json

class SQLMapRunner:
    """Runner for SQLMap to detect and exploit SQL injection vulnerabilities."""

    def __init__(self, sqlmap_path: str = "sqlmap", logger: Optional[logging.Logger] = None):
        """
        Initialize the SQLMap runner.

        Args:
            sqlmap_path: Path to the sqlmap.py script or sqlmap executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("sqlmap_runner")
        self.sqlmap_path = sqlmap_path # Often 'sqlmap' or 'sqlmap.py'
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if SQLMap is installed and executable."""
        cmd = []
        # SQLMap can be a direct executable or a python script
        if not self.sqlmap_path.endswith(".py") and not os.access(self.sqlmap_path, os.X_OK):
            # If not a .py script and not directly executable, try with python
             if os.access(self.sqlmap_path + ".py", os.X_OK) or os.path.exists(self.sqlmap_path + ".py"):
                 cmd.append("python3") # Or "python" depending on sqlmap version / system
                 cmd.append(self.sqlmap_path + ".py") # Assuming it's a python script
             else: # Try direct execution if path seems to imply it
                 cmd.append(self.sqlmap_path)
        elif self.sqlmap_path.endswith(".py"):
            cmd.append("python3")
            cmd.append(self.sqlmap_path)
        else: # Assume it's an executable in PATH
            cmd.append(self.sqlmap_path)

        cmd.append("--version")
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=False, timeout=15)
            # SQLMap version is usually in stdout
            if "sqlmap" in result.stdout.lower() and "version" in result.stdout.lower():
                self.logger.info(f"SQLMap found: {result.stdout.strip().splitlines()[0]}")
                return True
            elif "sqlmap" in result.stderr.lower() and "version" in result.stderr.lower(): # sometimes in stderr
                self.logger.info(f"SQLMap found: {result.stderr.strip().splitlines()[0]}")
                return True
            else:
                self.logger.warning(f"SQLMap not found or not working correctly with cmd {' '.join(cmd)}. stdout: {result.stdout}, stderr: {result.stderr}")
                return False
        except FileNotFoundError:
            self.logger.error(f"SQLMap or python not found. Command: {' '.join(cmd)}. Please install SQLMap or provide the correct path.")
            return False
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout checking SQLMap availability with command: {' '.join(cmd)}")
            return False
        except Exception as e:
            self.logger.error(f"Error checking SQLMap availability: {e}")
            return False

    def _parse_sqlmap_output(self, output_text: str, log_file_path: Optional[str] = None) -> Dict[str, Any]:
        """
        Rudimentary parsing of SQLMap text output.
        SQLMap's output is complex. This focuses on identifying if an injection was found.
        For more detailed results, SQLMap's session files or CSV output might be better,
        but that complicates the wrapper significantly.
        """
        results = {
            "vulnerable_parameters": [],
            "injection_type": None,
            "dbms": None,
            "log_summary": [],
            "injection_found": False
        }

        # Check for common indicators of success
        if "identified the following injection point(s)" in output_text or \
           "Parameter:" in output_text and "Type:" in output_text and "Title:" in output_text or \
           "is vulnerable" in output_text.lower():
            results["injection_found"] = True
        
        # Try to extract vulnerable parameter and type
        # Example: Parameter: id (GET)
        #          Type: boolean-based blind
        #          Title: AND boolean-based blind - WHERE or HAVING clause
        #          Payload: id=1 AND 9382=9382
        param_matches = re.findall(r"Parameter:\s*(.*?)\s*\((GET|POST|COOKIE|HEADER|URI)\)", output_text, re.IGNORECASE)
        type_matches = re.findall(r"Type:\s*(.*)", output_text, re.IGNORECASE)
        title_matches = re.findall(r"Title:\s*(.*)", output_text, re.IGNORECASE)
        dbms_matches = re.findall(r"back-end DBMS:\s*(.*)", output_text, re.IGNORECASE)

        for p_match in param_matches:
            param_name, param_method = p_match
            if param_name not in [vp["name"] for vp in results["vulnerable_parameters"]]: # Avoid duplicates
                 results["vulnerable_parameters"].append({"name": param_name.strip(), "method": param_method.strip()})
        
        if type_matches:
            results["injection_type"] = type_matches[0].strip()
        elif title_matches: # Fallback to title if type not found
             results["injection_type"] = title_matches[0].strip()


        if dbms_matches:
            results["dbms"] = dbms_matches[0].strip().splitlines()[0] # Take first line if multi-line

        # If a log file was used, we can try to get structured data from there
        # SQLMap saves session data in output_dir/target_url/session.sqlite
        # and logs in output_dir/target_url/log
        # Parsing these is out of scope for simple wrapper, but LLM could be instructed.
        if log_file_path and os.path.exists(log_file_path):
            try:
                with open(log_file_path, 'r', errors='ignore') as lf:
                    log_content = lf.readlines()
                    # Extract key lines
                    for line in log_content:
                        if "[INFO] testing " in line or \
                           "[PAYLOAD]" in line or \
                           "[CRITICAL]" in line or \
                           "identified injection" in line or \
                           "is vulnerable" in line.lower():
                            results["log_summary"].append(line.strip())
            except Exception as e_log:
                self.logger.warning(f"Could not fully read SQLMap log file {log_file_path}: {e_log}")
        
        # If any vulnerable parameter is found, mark injection_found as true
        if results["vulnerable_parameters"]:
            results["injection_found"] = True

        return results

    def scan(self, target_url: str, data: Optional[str] = None,
             level: int = 1, risk: int = 1, check_dbms: bool = False,
             list_dbs: bool = False, current_db: bool = False,
             batch_mode: bool = True, # Essential for automation
             additional_args: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run SQLMap against a target URL.

        Args:
            target_url: The URL to test (e.g., "http://example.com/vuln.php?id=1").
            data: POST data string (e.g., "user=test&pass=test").
            level: Level of tests to perform (1-5, default 1).
            risk: Risk of tests to perform (1-3, default 1).
            check_dbms: Try to identify the DBMS (--dbms).
            list_dbs: Enumerate databases (--dbs).
            current_db: Get current database (--current-db).
            batch_mode: Never ask for user input, use default behavior.
            additional_args: List of additional SQLMap arguments.

        Returns:
            Dict containing scan results.
        """
        if not self.available:
            return {"error": "SQLMap scanner not available."}

        results: Dict[str, Any] = {
            "target_url_scanned": target_url,
            "scan_output_summary": {},
            "full_stdout": None,
            "error": None,
            "command_used": ""
        }
        
        output_dir = None
        log_file = None

        try:
            # SQLMap creates an output directory based on target. We can specify one.
            # Using a temp directory for session files.
            output_dir = tempfile.mkdtemp(prefix="sqlmap_output_")
            # The log file will be inside this dir, sqlmap creates it.
            # Sanitizing target_url for directory naming is complex; let sqlmap handle it within output_dir.
            
            cmd = []
            if self.sqlmap_path.endswith(".py"):
                cmd.append("python3") # Or python
            cmd.append(self.sqlmap_path)

            cmd.extend(["-u", target_url])
            cmd.extend(["--output-dir", output_dir]) # Store session files here

            if data:
                cmd.extend(["--data", data])
            
            cmd.extend(["--level", str(level)])
            cmd.extend(["--risk", str(risk)])

            if batch_mode:
                cmd.append("--batch")
            
            # Specific actions
            if check_dbms:
                cmd.append("--dbms") # This flag alone doesn't do much without a value usually, --fingerprint is better
                if "--fingerprint" not in (additional_args or []): cmd.append("--fingerprint")
            if list_dbs:
                cmd.append("--dbs")
            if current_db:
                cmd.append("--current-db")
            
            if additional_args:
                cmd.extend(additional_args)
            
            results["command_used"] = " ".join(cmd)
            self.logger.info(f"Running SQLMap command: {results['command_used']}")

            # SQLMap can be very interactive if not in batch mode.
            # It also can take a very long time.
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, errors='replace')
            stdout, _ = process.communicate(timeout=3600) # 1 hour timeout, adjust as needed

            results["full_stdout"] = stdout
            
            # SQLMap usually exits 0 even if vulnerabilities are found.
            # Need to parse output.
            # The log file path is usually output_dir/sanitized_target/log
            # Finding the exact log file path sqlmap creates can be tricky.
            # We'll just look for a 'log' file in the output_dir structure.
            log_file_path_guess = None
            if os.path.exists(output_dir):
                for root, _, files in os.walk(output_dir):
                    if 'log' in files:
                        log_file_path_guess = os.path.join(root, 'log')
                        break
            
            results["scan_output_summary"] = self._parse_sqlmap_output(stdout, log_file_path_guess)
            
            if process.returncode != 0:
                 self.logger.warning(f"SQLMap process exited with code {process.returncode}. This might be ok or indicate an issue.")
                 # Don't set error yet, as output parsing is primary.

            if "Traceback" in stdout or "[CRITICAL] " in stdout:
                if not results["scan_output_summary"].get("injection_found"): # If no injection found despite critical error
                    results["error"] = "SQLMap reported a critical error or traceback. Check full_stdout."
                    critical_lines = [line for line in stdout.splitlines() if "[CRITICAL]" in line or "Traceback" in line]
                    self.logger.error(f"SQLMap critical error/traceback: {' '.join(critical_lines[:3])}")


            return results

        except subprocess.TimeoutExpired:
            self.logger.error(f"SQLMap scan timed out for target: {target_url}")
            results["error"] = "SQLMap scan timed out."
            results["full_stdout"] = results.get("full_stdout", "") + "\n[INFO] Scan timed out."
            # Try to parse whatever output was captured before timeout
            results["scan_output_summary"] = self._parse_sqlmap_output(results["full_stdout"])
            return results
        except Exception as e:
            self.logger.error(f"Error running SQLMap scan: {e}")
            results["error"] = str(e)
            return results
        finally:
            if output_dir and os.path.exists(output_dir):
                # For debugging, you might want to keep this. For automation, clean up.
                # import shutil
                # shutil.rmtree(output_dir)
                # self.logger.info(f"Cleaned up SQLMap output directory: {output_dir}")
                results["output_dir_path"] = output_dir # Return path for potential manual inspection
                pass


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(levelname)s: %(message)s')
    scanner = SQLMapRunner()

    if scanner.available:
        # test_url = "http://testphp.vulnweb.com/listproducts.php?cat=1" # Known vulnerable
        test_url = "http://localhost/DVWA/vulnerabilities/sqli/?id=1&Submit=Submit#" # Example for DVWA (low security)
        # You'll need to set your DVWA security cookie if testing DVWA, e.g., via --cookie="security=low; PHPSESSID=..."
        # Or ensure the LLM can provide this if needed.

        print(f"Scanning target URL: {test_url}")
        # scan_results = scanner.scan(test_url, level=1, risk=1, list_dbs=True)
        scan_results = scanner.scan(test_url, level=1, risk=1, additional_args=["--cookie=\"security=low; PHPSESSID=your_session_id_here\""]) # Replace with actual cookie for DVWA

        print("\nScan Results:")
        if scan_results.get("error"):
            print(f"  Error: {scan_results['error']}")
        
        summary = scan_results.get("scan_output_summary", {})
        if summary.get("injection_found"):
            print("  SQL Injection Found!")
            print(f"    Vulnerable Parameters: {summary.get('vulnerable_parameters')}")
            print(f"    Injection Type: {summary.get('injection_type')}")
            print(f"    DBMS: {summary.get('dbms')}")
        else:
            print("  No SQL injection definitively identified by basic parsing (check full output).")

        if summary.get("log_summary"):
             print("\n  Key Log Lines:")
             for line in summary.get("log_summary", [])[:10]: # Print first 10 key lines
                 print(f"    {line}")
        
        print(f"\n  Command used: {scan_results.get('command_used')}")
        if scan_results.get("output_dir_path"):
            print(f"  SQLMap session files in: {scan_results.get('output_dir_path')} (inspect manually if needed)")

        # print("\n  First 500 chars of SQLMap STDOUT:")
        # print(scan_results.get("full_stdout", "")[:500])
        
        # print("\nFull JSON Output of Wrapper:")
        # print(json.dumps(scan_results, indent=2, default=str))
    else:
        print("SQLMap scanner is not available.")