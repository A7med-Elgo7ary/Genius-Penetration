#!/usr/bin/env python3
"""
Wrapper for the Nmap network scanner.
"""

import subprocess
import xml.etree.ElementTree as ET
import json
import os
import logging
from typing import List, Dict, Any, Optional
import tempfile

class NmapScanner:
    """Wrapper for the Nmap network scanner."""

    def __init__(self, nmap_path: str = "nmap", logger: Optional[logging.Logger] = None):
        """
        Initialize the Nmap scanner wrapper.

        Args:
            nmap_path: Path to the nmap executable.
            logger: Optional logger instance.
        """
        self.logger = logger or logging.getLogger("nmap_scanner")
        self.nmap_path = nmap_path
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if Nmap is installed and executable."""
        try:
            result = subprocess.run([self.nmap_path, "-V"],
                                   capture_output=True, text=True, check=False)
            if result.returncode == 0 and "Nmap version" in result.stdout:
                self.logger.info(f"Nmap found: {result.stdout.strip().splitlines()[0]}")
                return True
            else:
                self.logger.warning(f"Nmap not found or not working correctly at {self.nmap_path}. stdout: {result.stdout}, stderr: {result.stderr}")
                return False
        except FileNotFoundError:
            self.logger.error(f"Nmap executable not found at {self.nmap_path}. Please install Nmap or provide the correct path.")
            return False
        except Exception as e:
            self.logger.error(f"Error checking Nmap availability: {e}")
            return False

    def _parse_nmap_xml(self, xml_output_file: str) -> List[Dict[str, Any]]:
        """
        Parse Nmap XML output into a more structured format.
        """
        hosts_data = []
        try:
            tree = ET.parse(xml_output_file)
            root = tree.getroot()

            for host_node in root.findall('host'):
                host_info = {
                    "ip_address": None,
                    "hostname": None,
                    "status": host_node.find('status').get('state') if host_node.find('status') is not None else "unknown",
                    "ports": [],
                    "os_matches": []
                }

                # Get IP address
                address_node = host_node.find("address[@addrtype='ipv4']")
                if address_node is None:
                    address_node = host_node.find("address[@addrtype='ipv6']") # Support IPv6
                if address_node is not None:
                    host_info["ip_address"] = address_node.get('addr')

                # Get hostname
                hostname_node = host_node.find("hostnames/hostname")
                if hostname_node is not None:
                    host_info["hostname"] = hostname_node.get('name')
                
                # Get OS matches
                os_node = host_node.find("os")
                if os_node is not None:
                    for match_node in os_node.findall("osmatch"):
                        host_info["os_matches"].append({
                            "name": match_node.get("name"),
                            "accuracy": match_node.get("accuracy")
                        })

                # Get port information
                ports_node = host_node.find('ports')
                if ports_node is not None:
                    for port_node in ports_node.findall('port'):
                        port_info = {
                            "port_id": port_node.get('portid'),
                            "protocol": port_node.get('protocol'),
                            "state": port_node.find('state').get('state') if port_node.find('state') is not None else "unknown",
                            "service_name": None,
                            "service_product": None,
                            "service_version": None,
                            "scripts": []
                        }
                        service_node = port_node.find('service')
                        if service_node is not None:
                            port_info["service_name"] = service_node.get('name')
                            port_info["service_product"] = service_node.get('product')
                            port_info["service_version"] = service_node.get('version')
                        
                        # Get script outputs
                        for script_node in port_node.findall('script'):
                            port_info["scripts"].append({
                                "id": script_node.get("id"),
                                "output": script_node.get("output")
                            })
                        host_info["ports"].append(port_info)
                hosts_data.append(host_info)
        except ET.ParseError as e:
            self.logger.error(f"Error parsing Nmap XML output {xml_output_file}: {e}")
        except Exception as e:
            self.logger.error(f"Unexpected error parsing Nmap XML {xml_output_file}: {e}")
        return hosts_data

    def scan(self, targets: List[str], ports: Optional[str] = None,
             arguments: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Run an Nmap scan on the specified targets.

        Args:
            targets: List of targets (IPs, hostnames, CIDR ranges).
            ports: Port specification (e.g., "80,443", "1-1000", "T:22,U:53"). If None, Nmap default (top 1000).
            arguments: List of additional Nmap arguments (e.g., ["-sV", "-sC", "-T4"]).
                       Commonly used:
                       -sS (TCP SYN scan)
                       -sU (UDP Scan)
                       -sV (Version detection)
                       -sC (Default scripts)
                       -O (OS detection, needs root)
                       -A (Aggressive: OS detection, version detection, script scanning, and traceroute)
                       -T<0-5> (Timing template)
                       -Pn (Treat all hosts as online -- skip host discovery)


        Returns:
            Dict containing scan results.
        """
        if not self.available:
            return {"error": "Nmap scanner not available."}

        results: Dict[str, Any] = {
            "targets_scanned": targets,
            "arguments_used": arguments or [],
            "scan_data": [],
            "error": None,
            "raw_xml_file": None
        }
        
        xml_output_file = None
        try:
            # Create a temporary file for XML output
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".xml") as tmp_xml:
                xml_output_file = tmp_xml.name
            
            cmd = [self.nmap_path, "-oX", xml_output_file]

            if ports:
                cmd.extend(["-p", ports])
            
            if arguments:
                cmd.extend(arguments)
            
            cmd.extend(targets)
            
            results["command_used"] = " ".join(cmd)
            self.logger.info(f"Running Nmap command: {results['command_used']}")
            
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate(timeout=1800) # 30-minute timeout, adjust as needed

            if stderr:
                self.logger.warning(f"Nmap stderr: {stderr.strip()}")
                if "ERROR" in stderr.upper() or "FAILED" in stderr.upper():
                    results["error"] = stderr.strip()
            
            if process.returncode != 0 and not results["error"]:
                results["error"] = f"Nmap process exited with code {process.returncode}. Stderr: {stderr.strip()}"
                self.logger.error(f"Nmap process failed. stdout: {stdout}, stderr: {stderr}")
            
            if os.path.exists(xml_output_file) and os.path.getsize(xml_output_file) > 0:
                results["scan_data"] = self._parse_nmap_xml(xml_output_file)
                results["raw_xml_file"] = xml_output_file # Keep path for potential later use by reporting agent
            elif not results["error"]:
                 results["error"] = "Nmap did not produce an XML output file or it was empty."
                 self.logger.warning(results["error"])
            
            return results

        except subprocess.TimeoutExpired:
            self.logger.error(f"Nmap scan timed out for targets: {targets}")
            results["error"] = "Nmap scan timed out."
            return results
        except Exception as e:
            self.logger.error(f"Error running Nmap scan: {e}")
            results["error"] = str(e)
            return results
        # Not deleting xml_output_file here as it might be useful for the ReportingAgent
        # The caller (VulnerabilityScanningAgent) should manage cleanup if needed,
        # or the temp file will be cleaned up when the object is garbage collected if not unlinked.
        # For long-running processes, explicit cleanup might be better.
        # For now, we return the path.

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(levelname)s: %(message)s')
    scanner = NmapScanner()

    if scanner.available:
        # test_targets = ["scanme.nmap.org"]
        test_targets = ["127.0.0.1"] # Scan localhost for testing
        # common_args = ["-sV", "-sC", "-T4"] # Version, Default Scripts, Timing
        common_args = ["-sV", "-T4", "-Pn"] # -Pn if testing localhost which might not respond to ping
        # test_ports = "22,80,443"
        test_ports = "1-1000"


        print(f"Scanning targets: {test_targets} with arguments: {common_args} on ports: {test_ports}")
        scan_results = scanner.scan(test_targets, ports=test_ports, arguments=common_args)

        print("\nScan Results:")
        if scan_results.get("error"):
            print(f"  Error: {scan_results['error']}")
        
        if scan_results.get("scan_data"):
            print("  Hosts Scanned:")
            for host in scan_results["scan_data"]:
                print(f"    Host: {host.get('ip_address')} ({host.get('hostname', 'N/A')}) - Status: {host.get('status')}")
                if host.get("os_matches"):
                    print(f"      OS Guesses:")
                    for os_match in host["os_matches"][:1]: # Show top OS guess
                        print(f"        - {os_match.get('name')} (Accuracy: {os_match.get('accuracy')}%)")
                print("      Open Ports:")
                for port in host.get("ports", []):
                    if port.get('state') == 'open':
                        service_info = f"{port.get('service_name', 'unknown')} {port.get('service_product', '')} {port.get('service_version', '')}".strip()
                        print(f"        - Port {port.get('port_id')}/{port.get('protocol')}: {service_info}")
                        for script in port.get("scripts", []):
                            print(f"          Script: {script.get('id')}, Output: {script.get('output', 'N/A')[:100]}...") # Truncate long script output
        else:
            print("  No scan data processed.")
        
        if scan_results.get("raw_xml_file"):
            print(f"  Raw XML output saved to: {scan_results.get('raw_xml_file')}")
            # Example: to clean up:
            # if os.path.exists(scan_results.get("raw_xml_file")):
            #    os.unlink(scan_results.get("raw_xml_file"))

        # print("\nFull JSON Output:")
        # print(json.dumps(scan_results, indent=2, default=str)) # default=str for any non-serializable data
    else:
        print("Nmap scanner is not available.")